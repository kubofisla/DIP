<!DOCTYPE html> 
<html lang="en">
	<head>
		<title>three.js webgl - cameras</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    </head>
    <body>

        <!--<img src="lut/myLut3.png" alt="Smiley face" height="256" width="256">-->
        <div style="text-align: center; display:block;">
            <select style="display:table-cell;
                vertical-align:middle; margin:auto;" id="DateSetSelect" onchange="setDataset(this.value)">
                <option value="0">Hlava</option>
                <option value="1">Ladviny</option>
                <option value="2">Torso</option>
                <!--<option value="4">Light hard tissue</option>-->
            </select>
            <select style="display:table-cell;
                vertical-align:middle; margin:auto;" id="LutSelect" onchange="setLUT(this.value)">
                <option value="4">Light hard tissue</option>
                <option value="1">Muscle</option>
                <option value="2">Light muscle</option>
                <option value="3">Hard tissue</option>
            </select>
            <select style="display:table-cell;
                vertical-align:middle; margin:auto;" id="ShaderType" onchange="makeAnimate()">
                <option value="xray">X-Ray</option>
                <option value="render">Render</option>
                <option value="mip">MIP</option>
                <option value="iso">Iso-surface</option>
            </select>
            <select style="display:table-cell;
                vertical-align:middle; margin:auto;" disabled="true" id="QualitySelect" onchange="changeQuality(this.value)">
                <option value="1">High</option>
                <option value="2">Medium</option>
                <option value="3">Low</option>
            </select>
            <input name="OpacityBar" type="range" id="sliderBar" min="0" max="100" step="1" value="50" onChange="setOpacity(this.value);" onInput="setOpacity(this.value);"/>
            <label><input type='checkbox' onclick='setBackground(this);' onInput='setBackground(this);'>Debug background</label>
            <input name="TrasholdBar" type="range" id="sliderBar" min="0" max="100" step="1" value="5" onChange="trasholdChange(this.value);" onInput="trasholdChange(this.value);"/> <label id="TrasholdLabel">Dens. trashold</label>
            <input name="CuttingPlaneBar" type="range" id="cutPlaneSliderBar" min="0" max="300" step="0.1" value="10" onChange="cutPlaneDistanceChange(this.value);" onInput="cutPlaneDistanceChange(this.value);"/> <label id="CutPlaneLabel">Cut Plane distance</label>
        </div>
        
        <div id="output"></div>
        
        <canvas id="myCanvas" style="display: block; border:1px solid #d3d3d3; color: black;"></canvas> 

        <script type="text/javascript">
            var alphaMulOneP = 0.000026;
            var alphaMul = 0.0013;
            var intensityT = 0.05;

            javascript: (function () { var script = document.createElement('script'); script.onload = function () { var stats = new Stats(); document.body.appendChild(stats.dom); requestAnimationFrame(function loop() { stats.update(); requestAnimationFrame(loop) }); }; script.src = '//rawgit.com/mrdoob/stats.js/master/build/stats.min.js'; document.head.appendChild(script); })()

            function setOpacity(opacity) {
                alphaMul = opacity * alphaMulOneP;
                makeAnimate();
            }

            function makeAnimate() {
                animate();
            }

            function trasholdChange(density) {
                intensityT = density / 100.;
                document.getElementById('TrasholdLabel').innerHTML = intensityT.toFixed(2);
                makeAnimate();
            }

            function cutPlaneDistanceChange(distance) {
                var cutPlaneDistance = distance / 100.;
                camera.near = cutPlaneDistance;
                camera.updateProjectionMatrix();
                document.getElementById('CutPlaneLabel').innerHTML = cutPlaneDistance.toFixed(2);
                makeAnimate();
            }

            function setBackground(cb) {
                if (cb.checked)
                    renderer.setClearColor(0x333F47);
                else
                    renderer.setClearColor(0x000000);
            }

            function setShader() {
                var e = document.getElementById("ShaderType");
                var type = e.options[e.selectedIndex].value;

                if (type == "render")
                    volumeCube.material = returnMaterialVolumeLUT();
                else if (type == "xray")
                    volumeCube.material = returnMaterialVolumeXray();
                else if (type == "mip")
                    volumeCube.material = returnMaterialVolumeMip();
                else if (type == "iso")
                    volumeCube.material = returnMaterialVolumeIso();
            }

            function setLUT(lutNo) {
                if (lutNo == "1")
                    lutTexture = loader.load("lut/myLut1.png", function myfunction(texture) {
                        lutTexture = texture;
                        makeAnimate();
                    });
                else if (lutNo == "2")
                    lutTexture = loader.load("lut/myLut2.png", function myfunction(texture) {
                        lutTexture = texture;
                        makeAnimate();
                    });
                else if (lutNo == "3")
                    lutTexture = loader.load("lut/myLut3.png", function myfunction(texture) {
                        lutTexture = texture;
                        makeAnimate();
                    });
                else if (lutNo == "4")
                    lutTexture = loader.load("lut/myLut4.png", function myfunction(texture) {
                        lutTexture = texture;
                        makeAnimate();
                    });
            }

            function setDataset(dsNo) {
                if (dsNo == 0) {
                    volumeTexture = hlavaTexture;
                    sizeInZ = 0.007;
                }
                else if (dsNo == 1) {
                    volumeTexture = oblickyTexture;
                    sizeInZ = 0.002;
                }
                else if (dsNo == 2) {
                    volumeTexture = torsoTexture;
                    sizeInZ = 0.0028;
                }
                refreshEmtySpaceSkipping(dsNo);

                makeAnimate();
            }

            function changeQuality(settNo) {
                if(settNo == "1") {
                    sizeOfTexture = 8192;
                    sizeOfImage = 512;
                    rayCastStep = 0.0005;
                    alphaMul = 0.0013;
                    alphaMulOneP = 0.000026;
                    sideImgCount = parseInt(sizeOfTexture / sizeOfImage, 10);
                }
                else if (settNo == "2") {
                    sizeOfTexture = 4096;
                    sizeOfImage = 256;
                    rayCastStep = 0.0015;
                    alphaMul = 0.004;
                    alphaMulOneP = 0.00008;
                    sideImgCount = parseInt(sizeOfTexture / sizeOfImage, 10);
                }
                else if (settNo == "3") {
                    sizeOfTexture = 1024;
                    sizeOfImage = 128;
                    rayCastStep = 0.0025;
                    alphaMul = 0.008;
                    alphaMulOneP = 0.00016;
                    sideImgCount = parseInt(sizeOfTexture / sizeOfImage, 10);
                }
                hlavaTexture = preprocessData("volumes/HEAD/",  83, 0);
                oblickyTexture = preprocessData("volumes/SET1/",  361, 1);
                torsoTexture = preprocessData("volumes/TORSO/",  394, 2);

                var e = document.getElementById("DateSetSelect");
                var type = e.options[e.selectedIndex].value;
                setDataset(type)
            }
        </script>

        <script src="./js/jquery-1.12.3.js"></script>
        <script src="./js/Stats.js"></script>
        <script src="./js/three.js"></script>
        <script src="./js/OrbitControls.js"></script>
        <script src="./DataProcessing.js"></script>
        <script src="./CutPlane.js"></script>
        

        <!-- Shaders -->
        <!-- Loading shader files -->

        <script id="vertex_shader" type="x-shader/x-vertex">
        </script>
        <script src="./shaders/fragmet_shader_xray.js" id="xray_fshader" type="x-shader/x-fragment">
        </script>
        <script src="./shaders/fragmet_shader_lut.js" id="lut_fshader" type="x-shader/x-fragment">
        </script>
        <script src="./shaders/fragmet_shader_mip.js" id="mip_fshader" type="x-shader/x-fragment">
        </script>
        <script src="./shaders/fragmet_shader_iso.js" id="iso_fshader" type="x-shader/x-fragment">
        </script>

        <script>
            function LoadShaders() {
                $("#vertex_shader").load("./shaders/vertex_shader.js");
                $("#xray_fshader").load("./shaders/fragmet_shader_xray.js");
                $("#lut_fshader").load("./shaders/fragmet_shader_lut.js");
                $("#mip_fshader").load("./shaders/fragmet_shader_mip.js");
                $("#iso_fshader").load("./shaders/fragmet_shader_iso.js");
            }
        </script>

        <!-- Shaders end -->

        <script>
            function SetupRenderEvents(canvas) {
                canvas.onmousedown = function (e) {
                    startLoop(true);
                }
                canvas.onmouseup = function (e) {
                    startLoop(false);
                }

                var mousewheelevt = (/Firefox/i.test(navigator.userAgent)) ? "DOMMouseScroll" : "mousewheel" //FF doesn't recognize mousewheel as of FF3.x

                if (canvas.attachEvent) //if IE (and Opera depending on user setting)
                    canvas.attachEvent("on" + mousewheelevt, zoomSceneRedraw)
                else if (canvas.addEventListener) //WC3 browsers
                    canvas.addEventListener(mousewheelevt, zoomSceneRedraw, false)

                function zoomSceneRedraw(e) {
                    startLoop(true);
                    startLoop(false);
                }
            }
        </script>

        <script>
            //KONSTANTA, pocet obrazkov ktore bude dokreslovat
            var postFrameCount = 1;
            //KONSTANTA, velkost bounding boxu
            var c_boxSize = 1.;
            //counter akutalneho obrazku dokreslenia
            var actualPostFrame = 0;

            var isRunning = false;

            var frontCube, backCube;

            var scene, frontScene, backScene;
            var camera, renderer, backRenderer, frontRenderer;
            var controls;
            var WIDTH,
                HEIGHT;
            var gl;
            var volumeCube;
            var cuttingPlane;
            var planeObject, rayPlaneObject;

            var coordBoxesArray = [];
            var undersampledData = new Array(3);

            var sizeOfTexture = 4096;
            var sizeOfImage = 256;
            var rayCastStep = 0.0015;
            alphaMul = 0.004;
            alphaMulOneP = 0.00008;
            var sizeInZ = 0.007;
            var sideImgCount = parseInt(sizeOfTexture / sizeOfImage, 10);
            var loader;
            var frontTexture, backTexture, volumeTexture, lutTexture;
            var oblickyTexture, hlavaTexture;
            var isLoaded = [false, false, false];
            var dataImages = new Array(3);

            document.getElementById("QualitySelect").selectedIndex = 1;

            init();

            function startLoop(state) {

                if (state && !isRunning) {
                    isRunning = true;
                    animate();             /// starts loop

                } else if (!state && isRunning) {
                    isRunning = false;
                }
            }

            function init() {

                for (i = 0; i < 3; i++) {
                    dataImages[i] = new Array(512);
                }
                //Shader files loading
                LoadShaders();

                // Create the scene and set the scene size.
                scene = new THREE.Scene();
                frontScene = new THREE.Scene();
                backScene = new THREE.Scene();

                WIDTH = 800;
                HEIGHT = 600;

                // Create a renderer and add it to the DOM.
                renderer = new THREE.WebGLRenderer({ antialias: true });
                renderer.setSize(WIDTH, HEIGHT);
                renderer.setPixelRatio(window.devicePixelRatio);
                renderer.autoClear = false;
                document.getElementById("output").appendChild(renderer.domElement);

                var canvas = renderer.domElement;
                SetupRenderEvents(canvas);

                // Initialize the GL context
                gl = initWebGL(canvas);

                // Create a camera, zoom it out from the model a bit, and add it to the scene.
                camera = new THREE.PerspectiveCamera(
                  35,         // Field of view
                  WIDTH / HEIGHT,  // Aspect ratio
                  .1,         // Near
                  10000       // Far
                );
                camera.position.set(2, 2, 2);
                frontScene.add(camera);
                backScene.add(camera);
                scene.add(camera);

                // Create an event listener that resizes the renderer with the browser window.
                window.addEventListener('resize', function () {
                    renderer.setSize(WIDTH, HEIGHT);
                    camera.aspect = WIDTH / HEIGHT;
                    camera.updateProjectionMatrix();
                });

                // Set the background color of the scene.
                renderer.setClearColor(0x000000, 0);
                // Add OrbitControls so that we can pan around with the mouse.
                controls = new THREE.OrbitControls(camera, renderer.domElement);
                //Nastavi pohlad kamery do stredu kocky
                controls.target.set(0.5, 0.5, 0.5);

                //LUT image
                loader = new THREE.TextureLoader()
                lutTexture = loader.load("lut/myLut4.png");

                //Load dataset
                hlavaTexture = preprocessData("volumes/HEAD/",  83, 0);
                oblickyTexture = preprocessData("volumes/SET1/",  361, 1);
                torsoTexture = preprocessData("volumes/TORSO/",  394, 2);
                volumeTexture = hlavaTexture;

                //Trieda na cutting plane
                cuttingPlane = new CutPlane(camera, controls);

                //Create cube
                frontCube = baseFrontCube(jsCubeGeometry(0, 0, 1, c_boxSize));
                backCube = baseBackCube(jsCubeGeometry(0, 0, 1, c_boxSize));

                //frontScene.add(frontCube);
                //backScene.add(backCube);
                //scene.add(jsBlackCube(0, 0, 1, c_boxSize));

                frontTexture = new THREE.WebGLRenderTarget(WIDTH, HEIGHT, { minFilter: THREE.LinearFilter, magFilter: THREE.LinearMipMapNearestFilter, format: THREE.RGBFormat, type: THREE.HalfFloatType });
                backTexture = new THREE.WebGLRenderTarget(WIDTH, HEIGHT, { minFilter: THREE.LinearFilter, magFilter: THREE.LinearMipMapNearestFilter, format: THREE.RGBFormat, type: THREE.HalfFloatType });

                //create volume cube
                var cubeGeom = jsCubeGeometry(0, 0, 1, c_boxSize);
                setCuttingPlaneLines(cubeGeom);
                volumeCube = rayCube(cubeGeom);

                scene.add(volumeCube);
            }

            function refreshEmtySpaceSkipping(datasetIndex) {
                //zmazanie objektov
                clearScene(frontScene);
                clearScene(backScene);

                addFrontCubes(datasetIndex);
            }

            function clearScene(scene) {
                for (var i = scene.children.length - 1; i >= 0; i--) {
                    if (scene.children[i] instanceof THREE.Mesh)
                        scene.remove(scene.children[i]);
                }
            }

            function addFrontCubes(datasetIndex) {
                var cubeSize = c_boxSize / undersampledSize;
                var it = 0;

                for (var z = 1.; z > 0.; z -= cubeSize) {
                    for (var y = 1. - cubeSize; y >= 0.; y -= cubeSize) {
                        for (var x = 0.; x < 1.; x += cubeSize) {
                            if (undersampledData[datasetIndex][it + 1] > 0) {
                                frontScene.add(baseFrontCube(jsCubeGeometry(x, y, z, cubeSize)));
                                backScene.add(baseBackCube(jsCubeGeometry(x, y, z, cubeSize)));
                                //scene.add(baseFrontCube(jsCubeGeometry(x, y, z, cubeSize)));
                            }
                            it += 2;
                        }
                    }
                }

                //frontScene.remove(frontCube);
                //backScene.remove(backCube);
            }

            function SetCubeOrder(cameraPosition) {
                //Vyhladavacie pole
                var sortArray = [];

                //Vlozenie boxov z backsceny
                //for (var i = 0; i < backScene.children.length; i++) {
                //    if (!(backScene.children[i] instanceof THREE.Mesh))
                //        continue;
                    //objekt s vzdialenostov
                    //var sortObj = new MeshObject(backScene.children[i], 0);
                for (var i = 0; i < scene.children.length; ) {
                    if (!(scene.children[i] instanceof THREE.Mesh)) {
                        i++;
                        continue;
                    }
                    var sortObj = new MeshObject(scene.children[i], 0);
                    //nastavenie vzdialenosti ku kamere
                    sortObj.SetDistance(cameraPosition);
                    sortArray.push(sortObj);
                    scene.remove(sortObj.SceneObject);
                }

                //zoradenie pola
                sortArray.sort(function (a, b) {
                    return a.Distance - b.Distance;
                });
                //nastavenie poradia
                for (var i = 0; i < sortArray.length; i++) {
                    scene.add(sortArray[i].SceneObject);
                    //sortArray[i].SceneObject.renderOrder = i;
                }
            }

            function createCubeGeometry(x, y, z, cubeOffset) {
                var cubeGeometry = new THREE.Geometry();

                var xO = 0;
                var yO = 0;
                var zO = 0;

                //Vlozenie vrcholov
                for (var i = 0; i < 8; i++) {
                    cubeGeometry.vertices.push(new THREE.Vector3(x + xO, y + yO, z + zO));
                    //prestavenie honot
                    if (i == 0 || i == 4) yO = cubeOffset;
                    else if (i == 1 || i == 5) xO = cubeOffset;
                    else if (i == 2 || i == 6) yO = 0;
                    else if (i == 3) { xO = 0; yO = 0; zO = 0; }
                }

                //Nastavenie farieb
                for (var i = 0; i < 8; i++) {
                    cubeGeometry.colors.push(new THREE.Color(cubeGeometry.vertices[i].x, cubeGeometry.vertices[i].y, 1 - cubeGeometry.vertices[i].z));
                }

                //front
                cubeGeometry.faces.push(new THREE.Face3(0, 2, 1));
                cubeGeometry.faces.push(new THREE.Face3(0, 3, 2));
                //bot
                cubeGeometry.faces.push(new THREE.Face3(0, 1, 4));
                cubeGeometry.faces.push(new THREE.Face3(1, 5, 4));
                //top
                cubeGeometry.faces.push(new THREE.Face3(2, 7, 6));
                cubeGeometry.faces.push(new THREE.Face3(3, 7, 2));
                //left
                cubeGeometry.faces.push(new THREE.Face3(0, 4, 7));
                cubeGeometry.faces.push(new THREE.Face3(0, 7, 3));
                //right
                cubeGeometry.faces.push(new THREE.Face3(1, 6, 5));
                cubeGeometry.faces.push(new THREE.Face3(1, 2, 6));
                //back
                cubeGeometry.faces.push(new THREE.Face3(5, 6, 7));
                cubeGeometry.faces.push(new THREE.Face3(5, 7, 4));
            }

            //http://stackoverflow.com/questions/10330342/threejs-assign-different-colors-to-each-vertex-in-a-geometry
            //Tvorba kocky pomocou Box geometry
            function jsCubeGeometry(x, y, z, size) {
                var face, numberOfSides, vertexIndex;
                var faceIndices = ['a', 'b', 'c', 'd'];

                //load geometry
                var cubeGeometry = new THREE.BoxGeometry(size, size, size);
                cubeGeometry = cubeGeometry.translate(x + size / 2, y + size / 2, z - size / 2);

                //Nastavenie farieb
                for (var i = 0; i < 8; i++) {
                    cubeGeometry.colors.push(new THREE.Color(cubeGeometry.vertices[i].x, cubeGeometry.vertices[i].y, 1 - cubeGeometry.vertices[i].z));
                }

                //nastavenie face colors
                for (var i = 0; i < cubeGeometry.faces.length; i++) {
                    face = cubeGeometry.faces[i];
                    numberOfSides = (face instanceof THREE.Face3) ? 3 : 4;
                    for (var j = 0; j < numberOfSides; j++) {
                        vertexIndex = face[faceIndices[j]];
                        face.vertexColors[j] = cubeGeometry.colors[vertexIndex];
                    }
                }

                return cubeGeometry;
            }

            //Tvorba kocky pomocou Box geometry
            function jsBlackCube(x, y, z, size) {
                //load geometry
                var cubeGeometry = new THREE.BoxGeometry(size, size, size);
                cubeGeometry = cubeGeometry.translate(x + size / 2, y + size / 2, z - size / 2);

                //load material
                var cubeMaterial = new THREE.MeshBasicMaterial({
                    side: THREE.FrontSide,
                    color: 0x000000,
                    depthFunc: THREE.LessDepth
                });

                return new THREE.Mesh(cubeGeometry, cubeMaterial);
            }

            function setCuttingPlaneLines(cubeGeometry) {
                cuttingPlane.setLines([]);
                //hrany kocky, pre testovanie prienikov
                cuttingPlane.addLine(new THREE.Line3(cubeGeometry.vertices[0], cubeGeometry.vertices[1]));
                cuttingPlane.addLine(new THREE.Line3(cubeGeometry.vertices[1], cubeGeometry.vertices[3]));
                cuttingPlane.addLine(new THREE.Line3(cubeGeometry.vertices[3], cubeGeometry.vertices[2]));
                cuttingPlane.addLine(new THREE.Line3(cubeGeometry.vertices[2], cubeGeometry.vertices[0]));

                cuttingPlane.addLine(new THREE.Line3(cubeGeometry.vertices[0], cubeGeometry.vertices[5]));
                cuttingPlane.addLine(new THREE.Line3(cubeGeometry.vertices[1], cubeGeometry.vertices[4]));
                cuttingPlane.addLine(new THREE.Line3(cubeGeometry.vertices[2], cubeGeometry.vertices[7]));
                cuttingPlane.addLine(new THREE.Line3(cubeGeometry.vertices[3], cubeGeometry.vertices[6]));

                cuttingPlane.addLine(new THREE.Line3(cubeGeometry.vertices[4], cubeGeometry.vertices[5]));
                cuttingPlane.addLine(new THREE.Line3(cubeGeometry.vertices[5], cubeGeometry.vertices[7]));
                cuttingPlane.addLine(new THREE.Line3(cubeGeometry.vertices[7], cubeGeometry.vertices[6]));
                cuttingPlane.addLine(new THREE.Line3(cubeGeometry.vertices[6], cubeGeometry.vertices[4]));

                return cubeGeometry;
            }

            function baseFrontCube(cubeGeometry) {
                var cubeMaterial = new THREE.MeshBasicMaterial({
                    side: THREE.DoubleSide,
                    vertexColors: THREE.VertexColors
                });

                return new THREE.Mesh(cubeGeometry, cubeMaterial);
            }

            function baseBackCube(cubeGeometry) {
                var cubeMaterial = new THREE.MeshBasicMaterial({
                    side: THREE.BackSide,
                    vertexColors: THREE.VertexColors,
                    depthFunc: THREE.GreaterDepth
                });

                return new THREE.Mesh(cubeGeometry, cubeMaterial);
            }

            function rayCube(cubeGeometry) {
                var e = document.getElementById("ShaderType");
                var type = e.options[e.selectedIndex].value;

                if (type == "render")
                    shaderMaterial = returnMaterialVolumeLUT();
                else if (type == "xray")
                    shaderMaterial = returnMaterialVolumeXray();
                else if (type == "mip")
                    shaderMaterial = returnMaterialVolumeMip();
                else if (type == "iso")
                    shaderMaterial = returnMaterialVolumeIso();

                return new THREE.Mesh(cubeGeometry, shaderMaterial);
            }

            function returnMaterialVolumeXray() {
                var baseUniforms = {
                    frontFace: { type: "t", value: frontTexture },
                    backFace: { type: "t", value: backTexture },
                    volume1: { type: "t", value: volumeTexture[0] },
                    volume2: { type: "t", value: volumeTexture[1] },
                    volume3: { type: "t", value: volumeTexture[2] },
                    volume4: { type: "t", value: volumeTexture[3] },
                    size: { type: "v2", value: new THREE.Vector2(WIDTH, HEIGHT) },
                    alphaMultiplier: { type: "f", value: alphaMul },
                    cntInRow: { type: "i", value: sideImgCount },
                    step: { type: "f", value: rayCastStep },
                    zSize: { type: "f", value: sizeInZ }
                };
                var shaderMaterial =
                new THREE.ShaderMaterial({
                    side: THREE.DoubleSide,
                    uniforms: baseUniforms,
                    vertexShader: document.getElementById('vertex_shader').innerHTML,
                    fragmentShader: document.getElementById('xray_fshader').innerHTML
                });

                return shaderMaterial;
            }

            function returnMaterialVolumeLUT() {
                var uniforms = {
                    frontFace: { type: "t", value: frontTexture },
                    backFace: { type: "t", value: backTexture },
                    volume1: { type: "t", value: volumeTexture[0] },
                    volume2: { type: "t", value: volumeTexture[1] },
                    volume3: { type: "t", value: volumeTexture[2] },
                    volume4: { type: "t", value: volumeTexture[3] },
                    transferFce: { type: "t", value: lutTexture },
                    size: { type: "v2", value: new THREE.Vector2(WIDTH, HEIGHT) },
                    alphaMultiplier: { type: "f", value: alphaMul },
                    cntInRow: { type: "i", value: sideImgCount },
                    step: { type: "f", value: rayCastStep },
                    zSize: { type: "f", value: sizeInZ },
                    texelSize: { type: "f", value: 1. / sizeOfTexture },
                    lightPos: { type: "v3", value: camera.position.clone().negate() }
                };

                var shaderMaterial =
                new THREE.ShaderMaterial({
                    side: THREE.DoubleSide,
                    uniforms: uniforms,
                    vertexShader: document.getElementById('vertex_shader').innerHTML,
                    fragmentShader: document.getElementById('lut_fshader').innerHTML
                });

                return shaderMaterial;
            }

            function returnMaterialVolumeMip() {
                var baseUniforms = {
                    frontFace: { type: "t", value: frontTexture },
                    backFace: { type: "t", value: backTexture },
                    volume1: { type: "t", value: volumeTexture[0] },
                    volume2: { type: "t", value: volumeTexture[1] },
                    volume3: { type: "t", value: volumeTexture[2] },
                    volume4: { type: "t", value: volumeTexture[3] },
                    size: { type: "v2", value: new THREE.Vector2(WIDTH, HEIGHT) },
                    alphaMultiplier: { type: "f", value: alphaMul },
                    cntInRow: { type: "i", value: sideImgCount },
                    step: { type: "f", value: rayCastStep },
                    zSize: { type: "f", value: sizeInZ }
                };
                var shaderMaterial =
                new THREE.ShaderMaterial({
                    side: THREE.DoubleSide,
                    uniforms: baseUniforms,
                    vertexShader: document.getElementById('vertex_shader').innerHTML,
                    fragmentShader: document.getElementById('mip_fshader').innerHTML
                });

                return shaderMaterial;
            }

            function returnMaterialVolumeIso() {
                var baseUniforms = {
                    frontFace: { type: "t", value: frontTexture },
                    backFace: { type: "t", value: backTexture },
                    volume1: { type: "t", value: volumeTexture[0] },
                    volume2: { type: "t", value: volumeTexture[1] },
                    volume3: { type: "t", value: volumeTexture[2] },
                    volume4: { type: "t", value: volumeTexture[3] },
                    size: { type: "v2", value: new THREE.Vector2(WIDTH, HEIGHT) },
                    alphaMultiplier: { type: "f", value: alphaMul },
                    cntInRow: { type: "i", value: sideImgCount },
                    step: { type: "f", value: rayCastStep },
                    zSize: { type: "f", value: sizeInZ },
                    textureSide: { type: "i", value: sizeOfTexture },
                    texelSize: { type: "f", value: 1. / sizeOfTexture },
                    intensityTreshold: { type: "f", value: intensityT },
                    lightPos: { type: "v3", value: camera.position.clone().negate() }
                };

                var shaderMaterial =
                new THREE.ShaderMaterial({
                    side: THREE.DoubleSide,
                    uniforms: baseUniforms,
                    vertexShader: document.getElementById('vertex_shader').innerHTML,
                    fragmentShader: document.getElementById('iso_fshader').innerHTML
                });

                return shaderMaterial;
            }

            function animate() {

                // Read more about requestAnimationFrame at http://www.paulirish.com/2011/requestanimationframe-for-smart-animating/
                if (isRunning)
                    requestAnimationFrame(animate);
                else {
                    actualPostFrame = 0;
                    postAnimate();
                }

                animateCore();
            }

            function animateCore() {
                controls.update();

                //Vypocet cutting plane
                var planeGeometry = cuttingPlane.cutBox();
                var newPlaneObject = baseFrontCube(planeGeometry);
                var newRayPlaneObject = rayCube(planeGeometry);

                //zmazanie cutting plane
                if (planeObject != undefined) {
                    frontScene.remove(planeObject);
                    //scene.remove(planeObject);
                    //scene.remove(rayPlaneObject);
                }
                planeObject = newPlaneObject;
                rayPlaneObject = newRayPlaneObject;
                //pridanie noveho cutting plane
                if (planeObject != undefined) {
                    frontScene.add(planeObject);
                    //scene.add(planeObject);
                    //scene.add(rayPlaneObject);
                }

                // Render front cube.
                renderer.render(frontScene, camera, frontTexture, true);

                //nastavenie depth bufferu na hodnotu 0
                gl.clearDepth(0.0);
                renderer.clearDepth();

                // Render back cube.
                renderer.render(backScene, camera, backTexture, true);
                gl.clearDepth(1.0);

                setShader();

                //ray casting
                renderer.render(scene, camera);
            }

            function postAnimate() {
                if (actualPostFrame < postFrameCount && !isRunning)
                    requestAnimationFrame(postAnimate);

                actualPostFrame++;
                animateCore();
            }

            function initWebGL(canvas) {
                gl = null;

                try {
                    // Try to grab the standard context. If it fails, fallback to experimental.
                    gl = canvas.getContext("webgl") || canvas.getContext("experimental-webgl");
                }
                catch (e) { }

                // If we don't have a GL context, give up now
                if (!gl) {
                    alert("Unable to initialize WebGL. Your browser may not support it.");
                    gl = null;
                }

                return gl;
            }
        </script>
    </body>
</html>