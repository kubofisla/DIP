<!DOCTYPE html> 
<html lang="en">
	<head>
		<title>three.js webgl - cameras</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    </head>
    <body>

        <!--<img src="lut/myLut3.png" alt="Smiley face" height="256" width="256">-->
        <div style="text-align: center; display:block;">
            <select style="display:table-cell;
                vertical-align:middle; margin:auto;" id="DateSetSelect" onchange="setDataset(this.value)">
                <option value="2">Hlava</option>
                <option value="1">Ladviny</option>
                <option value="3">Torso</option>
                <!--<option value="4">Light hard tissue</option>-->
            </select>
            <select style="display:table-cell;
                vertical-align:middle; margin:auto;" id="LutSelect" onchange="setLUT(this.value)">
                <option value="4">Light hard tissue</option>
                <option value="1">Muscle</option>
                <option value="2">Light muscle</option>
                <option value="3">Hard tissue</option>
            </select>
            <select style="display:table-cell;
                vertical-align:middle; margin:auto;" id="ShaderType" onchange="setShader()">
                <option value="xray">X-Ray</option>
                <option value="render">Render</option>
                <option value="mip">MIP</option>
                <option value="iso">Iso-surface</option>
            </select>
            <select style="display:table-cell;
                vertical-align:middle; margin:auto;" disabled="true" id="QualitySelect" onchange="changeQuality(this.value)">
                <option value="1">High</option>
                <option value="2">Medium</option>
                <option value="3">Low</option>
            </select>
            <input name="OpacityBar" type="range" id="sliderBar" min="0" max="100" step="1" value="50" onChange="setOpacity(this.value);" />
            <label><input type='checkbox' onclick='setBackground(this);'>Debug background</label>
        </div>
        
        <div id="output"></div>
        
        <canvas id="myCanvas" style="display: block; border:1px solid #d3d3d3; color: black;"></canvas> 

        <script type="text/javascript">
            var alphaMulOneP = 0.000026;
            var alphaMul = 0.0013;

            function setOpacity(opacity) {
                alphaMul = opacity * alphaMulOneP;
                setShader();
            }

            function setBackground(cb) {
                if (cb.checked)
                    renderer.setClearColor(0x333F47);
                else
                    renderer.setClearColor(0x000000);
            }

            function setShader() {
                var e = document.getElementById("ShaderType");
                var type = e.options[e.selectedIndex].value;

                if (type == "render")
                    volumeCube.material = returnMaterialVolumeLUT();
                else if (type == "xray")
                    volumeCube.material = returnMaterialVolumeXray();
                else if (type == "mip")
                    volumeCube.material = returnMaterialVolumeMip();
                else if (type == "iso")
                    volumeCube.material = returnMaterialVolumeIso();
                animate();
            }

            function setLUT(lutNo) {
                if (lutNo == "1")
                    lutTexture = loader.load("lut/myLut1.png", setShader());
                else if (lutNo == "2")
                    lutTexture = loader.load("lut/myLut2.png", setShader());
                else if (lutNo == "3")
                    lutTexture = loader.load("lut/myLut3.png", setShader());
                else if (lutNo == "4")
                    lutTexture = loader.load("lut/myLut4.png", setShader());
                //setShader();
            }

            function setDataset(dsNo) {
                if (dsNo == "1") {
                    volumeTexture = oblickyTexture;
                    sizeInZ = 0.002;
                }
                else if (dsNo == "2") {
                    volumeTexture = hlavaTexture;
                    sizeInZ = 0.007;
                }
                else if (dsNo == "3") {
                    volumeTexture = torsoTexture;
                    sizeInZ = 0.0028;
                }
                setShader();
            }

            function changeQuality(settNo) {
                if(settNo == "1") {
                    sizeOfTexture = 8192;
                    sizeOfImage = 512;
                    rayCastStep = 0.0005;
                    alphaMul = 0.0013;
                    alphaMulOneP = 0.000026;
                    sideImgCount = parseInt(sizeOfTexture / sizeOfImage, 10);
                }
                else if (settNo == "2") {
                    sizeOfTexture = 4096;
                    sizeOfImage = 256;
                    rayCastStep = 0.0015;
                    alphaMul = 0.004;
                    alphaMulOneP = 0.00008;
                    sideImgCount = parseInt(sizeOfTexture / sizeOfImage, 10);
                }
                else if (settNo == "3") {
                    sizeOfTexture = 1024;
                    sizeOfImage = 128;
                    rayCastStep = 0.0025;
                    alphaMul = 0.008;
                    alphaMulOneP = 0.00016;
                    sideImgCount = parseInt(sizeOfTexture / sizeOfImage, 10);
                }
                hlavaTexture = preprocessData("volumes/HEAD/",  83, 0);
                oblickyTexture = preprocessData("volumes/SET1/",  361, 1);
                torsoTexture = preprocessData("volumes/TORSO/",  394, 2);

                var e = document.getElementById("DateSetSelect");
                var type = e.options[e.selectedIndex].value;
                setDataset(type)
            }
        </script>

        <script src="./js/three.js"></script>
        <script src="./js/OrbitControls.js"></script>
        <script src="./DataProcessing.js"></script>

        <!-- Shaders -->
        <script type="x-shader/x-vertex" id="vertexshader">

            // switch on high precision floats

            void main()
            {
                gl_Position = projectionMatrix * modelViewMatrix * vec4(position,1.0);
            }

        </script>

        <script type="x-shader/x-fragment" id="xrayfshader">

            #ifdef GL_ES
            precision highp float;
            #endif

            uniform sampler2D frontFace;
            uniform sampler2D backFace;

            uniform sampler2D volume1;
            uniform sampler2D volume2;
            uniform sampler2D volume3;
            uniform sampler2D volume4;

            uniform vec2 size;
            uniform float alphaMultiplier;
            uniform float step;
            uniform int cntInRow;
            uniform float zSize;

            int textureIndex = 0;

            vec2 mappingFce(vec3 position, int sideCnt){
                float partSide = float(1) / float(sideCnt);

                int imgCount = int(position.z * (float(1) / zSize));

                int yMul = int(imgCount / sideCnt);
                int xMul = int(imgCount - (yMul*sideCnt));

                textureIndex = yMul/sideCnt;
                yMul -= textureIndex*sideCnt;

                float xPos = (position.x / float(sideCnt)) + (partSide * float(xMul));
                float yPos = (position.y / float(sideCnt)) + (partSide * float(yMul));

                return vec2(xPos, yPos);
            }

            vec4 getColor(vec2 pos){

                if(textureIndex == 0)
                   return texture2D(volume1, pos.xy);
                if(textureIndex == 1)
                    return texture2D(volume2, pos.xy);
                if(textureIndex == 2)
                    return texture2D(volume3, pos.xy);
                if(textureIndex == 3)
                    return texture2D(volume4, pos.xy);
                
                return vec4(0.);
            }
            
            vec4 getFilteredColor(vec3 position, float partSide){
                float zAxis = position.z * (float(1) / zSize);  
                int imgIndex = int(zAxis);
                
                float colorDiff = zAxis - float(imgIndex);
                float opositeColorDiff = 1. - colorDiff;

                int yOffset = imgIndex / cntInRow;
                //int xOffset = imgIndex - cntInRow * int(floor( float(imgIndex) / float(cntInRow) )); //modulo
                int xOffset = int(mod(float(imgIndex), float(cntInRow)));

                textureIndex = yOffset/cntInRow;
                yOffset -= textureIndex*cntInRow;

                float xPos = (position.x / float(cntInRow)) + (partSide * float(xOffset));
                float yPos = (position.y / float(cntInRow)) + (partSide * float(yOffset));

                vec4 color1 = getColor(vec2(xPos, yPos));

                float interpoledColor = color1.g*opositeColorDiff + color1.b*colorDiff;

                return vec4(interpoledColor,interpoledColor,interpoledColor,1.);
            }

            void main()
            {
                vec4 value;
                vec4 result = vec4(0.0);

                vec4 fragCoord = vec4(gl_FragCoord.xy/size, 0.0, 0.0);
                vec3 frontPos = texture2D(frontFace, fragCoord.xy).rgb;
                vec3 backPos = texture2D(backFace, fragCoord.xy).rgb;
                vec3 direction = normalize(backPos - frontPos);

                vec3 actualPos = frontPos;

                float partSide = float(1) / float(cntInRow);
                float alfa = 0.0;

                if(length(direction) > 0.001)
                {
                    int steps = int(floor(length(direction)/step));
                    vec3 diff1 = direction / float(steps);

                    for (int i=0; i < 9999; i++) {

                        value = getFilteredColor(actualPos.xyz, partSide);
                        value.a = ((0.2126*value.r + 0.7152*value.g + 0.0722*value.b)*alphaMultiplier);
                        alfa += value.g * alphaMultiplier;
                        if(alfa >= 0.99)
                        {
                            alfa = 1.0;
                            break;
                        }
    
                        actualPos += diff1;
                        if(actualPos.x > 1.0 || actualPos.x < 0.0 || actualPos.y > 1.0 || actualPos.y < 0.0 || actualPos.z > 1.0 || actualPos.z < 0.0 )
                            break;
                    }
                }

                gl_FragColor=vec4(vec3(1.0,1.0,1.0)*alfa, 1.0);
            }

        </script>

        <script type="x-shader/x-fragment" id="lutfshader">

            #ifdef GL_ES
            precision highp float;
            #endif

            uniform sampler2D frontFace;
            uniform sampler2D backFace;

            uniform sampler2D volume1;
            uniform sampler2D volume2;
            uniform sampler2D volume3;
            uniform sampler2D volume4;

            uniform sampler2D transferFce;

            uniform vec2 size;
            uniform float alphaMultiplier;
            uniform int cntInRow;
            uniform float step;
            uniform float zSize;
            uniform float texelSize;

            const float SpecularContribution = 0.0;
            const float DiffuseContribution = 1.0 - SpecularContribution;
            const vec3 lightPos = vec3(0., 0., 1.);
            
            float zCount;

            vec3 direction;
            int textureIndex = 0;
            float partSide;

            float actualIntensity;
            vec4 actualPoint;
            vec4 top, bottom, left, right;
            int xOffset, yOffset;

            int imgIndex;
            float colorDiff;
            float opositeColorDiff;

            float sizeTextelX;
            float sizeTextelY;
            
            vec4 getColor(vec2 pos){

                if(textureIndex == 0)
                   return texture2D(volume1, pos.xy);
                if(textureIndex == 1)
                    return texture2D(volume2, pos.xy);
                if(textureIndex == 2)
                    return texture2D(volume3, pos.xy);
                if(textureIndex == 3)
                    return texture2D(volume4, pos.xy);
                
                return vec4(0.);
            }

            void mappingFceActual(vec3 position){
                imgIndex = int(floor(position.z * zCount));
                
                yOffset = imgIndex / cntInRow;
                xOffset = imgIndex - (yOffset * cntInRow);

                textureIndex = yOffset/cntInRow;
                yOffset -= textureIndex*cntInRow;

                float xPos = (position.x / float(cntInRow)) + (partSide * float(xOffset));
                float yPos = (position.y / float(cntInRow)) + (partSide * float(yOffset));

                actualPoint = getColor(vec2(xPos, yPos));
            }

            void mappingFceEviroment(vec3 position){
                float xPos = (position.x / float(cntInRow)) + (partSide * float(xOffset));
                float yPos = (position.y / float(cntInRow)) + (partSide * float(yOffset));

                right = getColor(vec2(xPos + sizeTextelX, yPos));
                left = getColor(vec2(xPos - sizeTextelX, yPos));
                top = getColor(vec2(xPos, yPos + sizeTextelY));
                bottom = getColor(vec2(xPos, yPos - sizeTextelY));
            }

            float getFilteredColor(float color1, float color2){
                
                return color1*opositeColorDiff + color2*colorDiff;
            }

            
            vec3 getActualNormal(){
                vec3 normal = vec3( getFilteredColor(right.g, right.b) - getFilteredColor(left.g, left.b),
                                    getFilteredColor(top.g, top.b) - getFilteredColor(bottom.g, bottom.b),
                                    getFilteredColor(actualPoint.r, actualPoint.g) - getFilteredColor(actualPoint.b, actualPoint.a));
                return normalize(normal);
            }

            float getLightIntensity(vec3 actualPos, vec3 normal){
                vec3 lightVec = normalize(lightPos - actualPos);
                vec3 viewVec = direction;
                float diffuse = max(dot(lightVec, normal), 0.3);
                
                //Aj odraz  
                //vec3 reflectVec = reflect(-lightVec, normal);
                //float spec = 0.0;
                //if (diffuse > 0.0){
                //spec = max(dot(reflectVec, viewVec), 0.2);
                //spec = pow(spec, 16.0);
                //}
                //return SpecularContribution*spec + DiffuseContribution*diffuse;
            
                return DiffuseContribution*diffuse;
            }

            void comupteColorDiff(vec3 actualPos){
                float zAxis = actualPos.z * zCount;
                int imgIndex = int(zAxis);

                colorDiff = zAxis - float(imgIndex);
                opositeColorDiff = 1. - colorDiff;
            }

            void main()
            {
                zCount = float(1) / zSize;

                vec4 value;
                vec4 result = vec4(0.0);

                vec2 fragCoord = gl_FragCoord.xy/size;
                vec3 frontPos = texture2D(frontFace, fragCoord).rgb;
                vec3 backPos = texture2D(backFace, fragCoord).rgb;
                direction = normalize(backPos - frontPos);
                
                sizeTextelX = texelSize;
                sizeTextelY = texelSize;
                    
                vec3 actualPos = frontPos;

                partSide = float(1) / float(cntInRow);

                if(length(direction) > 0.01)
                {
                    int steps = int(floor(length(direction)/step));
                    vec3 diff1 = direction / float(steps);
                    //float alfa = 0.0;

                    float LightIntensity = 1.0;

                    for (int i=0; i < 20000; i++) {
                        
                        mappingFceActual(actualPos);
                        comupteColorDiff(actualPos);
                        
                        actualIntensity = getFilteredColor(actualPoint.g, actualPoint.b);

                        if(actualIntensity > 0.0){
                            mappingFceEviroment(actualPos);
                            LightIntensity = getLightIntensity(actualPos, getActualNormal());
                        
                            value = texture2D(transferFce, vec2(actualIntensity, 0.5)) *  LightIntensity;

                            if(value.a < 0.9)
                                value.a *= alphaMultiplier*125.;

                            result.rgb = (1.0 - result.a) * value.rgb * value.a + result.rgb;
                            result.a = (1.0 - result.a) * value.a + result.a;
                        }

                        if(result.a >= 0.99)
                        {
                            result.a = 1.0;
                            break;
                        }
                        //if(i >= steps || actualPos.x > 1.0 || actualPos.x < 0.0 || actualPos.y > 1.0 || actualPos.y < 0.0 || actualPos.z > 1.0 || actualPos.z < 0.0 )
                            //break;
                        if(actualPos.x > 1.0 || actualPos.x < 0.0 || actualPos.y > 1.0 || actualPos.y < 0.0 || actualPos.z > 1.0 || actualPos.z < 0.0 )
                            break;
                        actualPos += diff1;
                    }
                }
                gl_FragColor = result;
            }

        </script>

        <script type="x-shader/x-fragment" id="mipfshader">

            #ifdef GL_ES
            precision highp float;
            #endif

            uniform sampler2D frontFace;
            uniform sampler2D backFace;

            uniform sampler2D volume1;
            uniform sampler2D volume2;
            uniform sampler2D volume3;
            uniform sampler2D volume4;

            uniform vec2 size;
            uniform float alphaMultiplier;
            uniform int cntInRow;
            uniform float step;
            uniform float zSize;

            int textureIndex = 0;

            vec2 mappingFce(vec3 position, int sideCnt){
                float partSide = float(1) / float(sideCnt);

                int imgCount = int(position.z * (float(1) / zSize));

                int yMul = int(imgCount / sideCnt);
                int xMul = int(imgCount - (yMul*sideCnt));

                textureIndex = yMul/sideCnt;
                yMul -= textureIndex*sideCnt;

                float xPos = (position.x / float(sideCnt)) + (partSide * float(xMul));
                float yPos = (position.y / float(sideCnt)) + (partSide * float(yMul));

                return vec2(xPos, yPos);
            }

            vec4 getColor(vec2 pos){

                if(textureIndex == 0)
                   return texture2D(volume1, pos.xy);
                if(textureIndex == 1)
                    return texture2D(volume2, pos.xy);
                if(textureIndex == 2)
                    return texture2D(volume3, pos.xy);
                if(textureIndex == 3)
                    return texture2D(volume4, pos.xy);
                
                return vec4(0.);
            }

            vec4 getFilteredColor(vec3 position, float partSide){
                float zAxis = position.z * (float(1) / zSize);  
                int imgIndex = int(zAxis);
                
                float colorDiff = zAxis - float(imgIndex);
                float opositeColorDiff = 1. - colorDiff;

                int yOffset = imgIndex / cntInRow;
                //int xOffset = imgIndex - cntInRow * int(floor( float(imgIndex) / float(cntInRow) )); //modulo
                int xOffset = int(mod(float(imgIndex), float(cntInRow)));

                textureIndex = yOffset/cntInRow;
                yOffset -= textureIndex*cntInRow;

                float xPos = (position.x / float(cntInRow)) + (partSide * float(xOffset));
                float yPos = (position.y / float(cntInRow)) + (partSide * float(yOffset));

                vec4 color1 = getColor(vec2(xPos, yPos));

                float interpoledColor = color1.y*opositeColorDiff + color1.z*colorDiff;

                return vec4(interpoledColor,interpoledColor,interpoledColor,1.);
            }
            
            void main()
            {
                float am = alphaMultiplier/0.004;

                vec4 value = vec4(0.0);

                vec2 fragCoord = gl_FragCoord.xy/size;
                vec3 frontPos = texture2D(frontFace, fragCoord).rgb;
                vec3 backPos = texture2D(backFace, fragCoord).rgb;
                vec3 direction = normalize(backPos - frontPos);

                vec3 actualPos = frontPos;

                float partSide = float(1) / float(cntInRow);

                if(length(direction) > 0.01)
                {
                    int steps = int(floor(length(direction)/step));
                    vec3 diff1 = direction / float(steps);

                    for (int i=0; i < 20000; i++) 
                    {
                        vec4 v = getFilteredColor(actualPos.xyz, partSide);
                        
                        if(v.g > value.g)
                        {
                            value = v;
                        }
                        
                        if(actualPos.x > 1.0 || actualPos.x < 0.0 || actualPos.y > 1.0 || actualPos.y < 0.0 || actualPos.z > 1.0 || actualPos.z < 0.0 )
                            break;
                        actualPos += diff1;
                    }
                }

                value = vec4(value.g, value.g, value.g, 1.);

                gl_FragColor = value;
            }

        </script>

        <script type="x-shader/x-fragment" id="isofshader">

            #ifdef GL_ES
            precision highp float;
            #endif

            uniform sampler2D frontFace;
            uniform sampler2D backFace;

            uniform sampler2D volume1;
            uniform sampler2D volume2;
            uniform sampler2D volume3;
            uniform sampler2D volume4;

            uniform vec2 size;
            uniform float alphaMultiplier;
            uniform int cntInRow;
            uniform float step;
            uniform float zSize;
            uniform int textureSide;
            uniform float texelSize;

            const float SpecularContribution = 0.0;
            const float DiffuseContribution = 1.0 - SpecularContribution;
            const vec3 lightPos = vec3(2., 0., -2.);
            
            float zCount;

            vec3 direction;
            int textureIndex = 0;
            float partSide;

            float actualIntensity;
            vec4 actualPoint;
            vec4 top, bottom, left, right;

            float xPos, yPos;

            int imgIndex;
            float colorDiff;
            float opositeColorDiff;

            float sizeTextelX;
            float sizeTextelY;
            
            vec4 getColor(vec2 pos){

                if(textureIndex == 0)
                   return texture2D(volume1, pos.xy);
                if(textureIndex == 1)
                    return texture2D(volume2, pos.xy);
                if(textureIndex == 2)
                    return texture2D(volume3, pos.xy);
                if(textureIndex == 3)
                    return texture2D(volume4, pos.xy);
                
                return vec4(0.);
            }

            void mappingFceActual(vec3 position){
                imgIndex = int(floor(position.z * zCount));
                
                int yOffset = imgIndex / cntInRow;
                int xOffset = imgIndex - (yOffset * cntInRow);

                textureIndex = yOffset/cntInRow;
                yOffset -= textureIndex*cntInRow;

                xPos = (position.x / float(cntInRow)) + (partSide * float(xOffset));
                yPos = (position.y / float(cntInRow)) + (partSide * float(yOffset));

                actualPoint = getColor(vec2(xPos, yPos));
            }

            void mappingFceEviroment(vec3 position){
                right = getColor(vec2(xPos + sizeTextelX, yPos));
                left = getColor(vec2(xPos - sizeTextelX, yPos));
                top = getColor(vec2(xPos, yPos + sizeTextelY));
                bottom = getColor(vec2(xPos, yPos - sizeTextelY));
            }

            float getFilteredColor(float color1, float color2){
                
                //return color1;
                return color1*opositeColorDiff + color2*colorDiff;
            }

            
            vec3 getActualNormal(){
                vec3 normal = vec3( getFilteredColor(right.g, right.b) - getFilteredColor(left.g, left.b),
                                    getFilteredColor(top.g, top.b) - getFilteredColor(bottom.g, bottom.b),
                                    getFilteredColor(actualPoint.r, actualPoint.g) - getFilteredColor(actualPoint.b, actualPoint.a));
                return normalize(normal);
            }

            float getLightIntensity(vec3 actualPos, vec3 normal){
                vec3 lightVec = normalize(lightPos - actualPos);
                vec3 viewVec = direction;
                float diffuse = max(dot(lightVec, normal), 0.3);
                
                //Aj odraz  
                //vec3 reflectVec = reflect(-lightVec, normal);
                //float spec = 0.0;
                //if (diffuse > 0.0){
                //spec = max(dot(reflectVec, viewVec), 0.2);
                //spec = pow(spec, 16.0);
                //}
                //return SpecularContribution*spec + DiffuseContribution*diffuse;
            
                return DiffuseContribution*diffuse;
            }

            void comupteColorDiff(vec3 actualPos){
                float zAxis = actualPos.z * zCount;
                int imgIndex = int(floor(zAxis));

                colorDiff = zAxis - float(imgIndex);
                opositeColorDiff = 1. - colorDiff;
            }

            void main()
            {
                zCount = float(1) / zSize;
                partSide = float(1) / float(cntInRow);
                
                vec4 value = vec4(0.0);
                float Idiff = 0.;

                vec2 fragCoord = gl_FragCoord.xy/size;
                vec3 frontPos = texture2D(frontFace, fragCoord).rgb;
                vec3 backPos = texture2D(backFace, fragCoord).rgb;
                direction = normalize(backPos - frontPos);

                vec3 isoColor = vec3(0.004*245., 0.004*228., 0.004*203.);

                vec3 actualPos = frontPos;
                
                sizeTextelX = texelSize;
                sizeTextelY = texelSize;

                if(length(direction) > 0.01)
                {
                    int steps = int(floor(length(direction)/step));
                    vec3 diff1 = direction / float(steps);

                    for (int i=0; i < 10000; i++)
                    {
                        mappingFceActual(actualPos);
                        comupteColorDiff(actualPos);

                        actualIntensity = getFilteredColor(actualPoint.g, actualPoint.b);

                        if(actualIntensity > 0.0)
                        {
                            //value.rgb = isoColor * actualIntensity;
                            value.rgb = isoColor;
                            value.a = 1.;

                            //shading
                            mappingFceEviroment(actualPos);
                            Idiff = getLightIntensity(actualPos, getActualNormal());
                            
                            break;
                        }
                        
                        if(actualPos.x > 1.0 || actualPos.x < 0.0 || actualPos.y > 1.0 || actualPos.y < 0.0 || actualPos.z > 1.0 || actualPos.z < 0.0 )
                            break;
                        actualPos += diff1;
                    }
                }
                gl_FragColor = value * Idiff;
            }

        </script>

        <script>
            function SetupRenderEvents(canvas) {
                canvas.onmousedown = function (e) {
                    startLoop(true);
                }
                canvas.onmouseup = function (e) {
                    startLoop(false);
                }

                var mousewheelevt = (/Firefox/i.test(navigator.userAgent)) ? "DOMMouseScroll" : "mousewheel" //FF doesn't recognize mousewheel as of FF3.x

                if (canvas.attachEvent) //if IE (and Opera depending on user setting)
                    canvas.attachEvent("on" + mousewheelevt, zoomSceneRedraw)
                else if (canvas.addEventListener) //WC3 browsers
                    canvas.addEventListener(mousewheelevt, zoomSceneRedraw, false)

                function zoomSceneRedraw(e) {
                    animate();
                }
            }
        </script>

        <script>
            var isRunning = false;

            var scene, frontScene, backScene;
            var camera, renderer;
            var WIDTH,
                HEIGHT;
            var gl;
            var volumeCube;
            var sizeOfTexture = 4096;
            var sizeOfImage = 256;
            var rayCastStep = 0.0015;
            //var sizeOfTexture = 8192;
            //var sizeOfImage = 512;
            //var rayCastStep = 0.0005;
            alphaMul = 0.004;
            alphaMulOneP = 0.00008;
            var sizeInZ = 0.007;
            var sideImgCount = parseInt(sizeOfTexture / sizeOfImage, 10);
            var loader;
            var frontTexture, backTexture, volumeTexture, lutTexture;
            var oblickyTexture, hlavaTexture;
            var isLoaded = [false, false, false];
            var dataImages = new Array(3);

            document.getElementById("QualitySelect").selectedIndex = 1;

            init();
            animate();

            function startLoop(state) {

                if (state && !isRunning) {
                    isRunning = true;
                    animate();             /// starts loop

                } else if (!state && isRunning) {
                    isRunning = false;
                }
            }

            function init() {
                for (i = 0; i < 3; i++) {
                    dataImages[i] = new Array(512);
                }

                // Create the scene and set the scene size.
                scene = new THREE.Scene();
                frontScene = new THREE.Scene();
                backScene = new THREE.Scene();

                WIDTH = 800;
                HEIGHT = 600;

                // Create a renderer and add it to the DOM.
                renderer = new THREE.WebGLRenderer({ antialias: true });
                renderer.setSize(WIDTH, HEIGHT);
                document.getElementById("output").appendChild(renderer.domElement);

                var canvas = renderer.domElement;
                SetupRenderEvents(canvas);

                // Initialize the GL context
                gl = initWebGL(canvas);

                // Create a camera, zoom it out from the model a bit, and add it to the scene.
                camera = new THREE.PerspectiveCamera(
                  35,         // Field of view
                  WIDTH / HEIGHT,  // Aspect ratio
                  .1,         // Near
                  10000       // Far
                );
                camera.position.set(0, 0, 2);
                camera.lookAt(new THREE.Vector3(0, 0, 0));
                frontScene.add(camera);
                backScene.add(camera);
                scene.add(camera);

                // Create an event listener that resizes the renderer with the browser window.
                window.addEventListener('resize', function () {
                    renderer.setSize(WIDTH, HEIGHT);
                    camera.aspect = WIDTH / HEIGHT;
                    camera.updateProjectionMatrix();
                });

                // Set the background color of the scene.
                renderer.setClearColor(0x000000);
                // Add OrbitControls so that we can pan around with the mouse.
                controls = new THREE.OrbitControls(camera, renderer.domElement);

                // Create a light, set its position, and add it to the scene.
                //var light = new THREE.PointLight(0xffffff);
                //light.position.set(-100, 200, 100);
                //frontScene.add(light);
                //backScene.add(light);
                //scene.add(light);

                //LUT image
                loader = new THREE.TextureLoader()
                lutTexture = loader.load("lut/myLut4.png");
                
                //Load dataset
                hlavaTexture = preprocessData("volumes/HEAD/",  83, 0);
                oblickyTexture = preprocessData("volumes/SET1/",  361, 1);
                torsoTexture = preprocessData("volumes/TORSO/",  394, 2);
                volumeTexture = hlavaTexture;
                //volumeTexture = new THREE.Texture();
                //changeQuality("2");

                //Create cube
                var frontCube = baseFrontCube(createCubeGeometry());
                var backCube = baseBackCube(createCubeGeometry());
                frontScene.add(frontCube);
                backScene.add(backCube);

                //texture for front face
                frontTexture = new THREE.WebGLRenderTarget(WIDTH, HEIGHT, { minFilter: THREE.LinearFilter, magFilter: THREE.LinearMipMapNearestFilter, format: THREE.RGBFormat });
                backTexture = new THREE.WebGLRenderTarget(WIDTH, HEIGHT, { minFilter: THREE.LinearFilter, magFilter: THREE.LinearMipMapNearestFilter, format: THREE.RGBFormat });

                volumeCube = rayCube(createCubeGeometry(), sideImgCount);
                //scene.add(frontCube);
                scene.add(volumeCube);
                
                //changeQuality("2");
            }

            function createCubeGeometry() {
                //load geometry
                var cubeGeometry = new THREE.Geometry();

                //add vertices
                cubeGeometry.vertices.push(new THREE.Vector3(-0.5, -0.5, 0.5));//0
                cubeGeometry.vertices.push(new THREE.Vector3(-0.5, 0.5, 0.5));//1
                cubeGeometry.vertices.push(new THREE.Vector3(0.5, 0.5, 0.5));//2
                cubeGeometry.vertices.push(new THREE.Vector3(0.5, -0.5, 0.5));//3
                cubeGeometry.vertices.push(new THREE.Vector3(-0.5, -0.5, -0.5));//4
                cubeGeometry.vertices.push(new THREE.Vector3(-0.5, 0.5, -0.5));//5
                cubeGeometry.vertices.push(new THREE.Vector3(0.5, 0.5, -0.5));//6
                cubeGeometry.vertices.push(new THREE.Vector3(0.5, -0.5, -0.5));//7

                //front
                cubeGeometry.faces.push(new THREE.Face3(0, 2, 1));
                cubeGeometry.faces[0].vertexColors[0] = new THREE.Color(0, 0, 0);
                cubeGeometry.faces[0].vertexColors[1] = new THREE.Color(1, 1, 0);
                cubeGeometry.faces[0].vertexColors[2] = new THREE.Color(0, 1, 0);
                cubeGeometry.faces.push(new THREE.Face3(0, 3, 2));
                cubeGeometry.faces[1].vertexColors[0] = new THREE.Color(0, 0, 0);
                cubeGeometry.faces[1].vertexColors[1] = new THREE.Color(1, 0, 0);
                cubeGeometry.faces[1].vertexColors[2] = new THREE.Color(1, 1, 0);
                //bot
                cubeGeometry.faces.push(new THREE.Face3(0, 1, 4));
                cubeGeometry.faces[2].vertexColors[0] = new THREE.Color(0, 0, 0);
                cubeGeometry.faces[2].vertexColors[1] = new THREE.Color(0, 1, 0);
                cubeGeometry.faces[2].vertexColors[2] = new THREE.Color(0, 0, 1);
                cubeGeometry.faces.push(new THREE.Face3(1, 5, 4));
                cubeGeometry.faces[3].vertexColors[0] = new THREE.Color(0, 1, 0);
                cubeGeometry.faces[3].vertexColors[1] = new THREE.Color(0, 1, 1);
                cubeGeometry.faces[3].vertexColors[2] = new THREE.Color(0, 0, 1);
                //top
                cubeGeometry.faces.push(new THREE.Face3(2, 7, 6));
                cubeGeometry.faces[4].vertexColors[0] = new THREE.Color(1, 1, 0);
                cubeGeometry.faces[4].vertexColors[1] = new THREE.Color(1, 0, 1);
                cubeGeometry.faces[4].vertexColors[2] = new THREE.Color(1, 1, 1);
                cubeGeometry.faces.push(new THREE.Face3(3, 7, 2));
                cubeGeometry.faces[5].vertexColors[0] = new THREE.Color(1, 0, 0);
                cubeGeometry.faces[5].vertexColors[1] = new THREE.Color(1, 0, 1);
                cubeGeometry.faces[5].vertexColors[2] = new THREE.Color(1, 1, 0);
                //left
                cubeGeometry.faces.push(new THREE.Face3(0, 4, 7));
                cubeGeometry.faces[6].vertexColors[0] = new THREE.Color(0, 0, 0);
                cubeGeometry.faces[6].vertexColors[1] = new THREE.Color(0, 0, 1);
                cubeGeometry.faces[6].vertexColors[2] = new THREE.Color(1, 0, 1);
                cubeGeometry.faces.push(new THREE.Face3(0, 7, 3));
                cubeGeometry.faces[7].vertexColors[0] = new THREE.Color(0, 0, 0);
                cubeGeometry.faces[7].vertexColors[1] = new THREE.Color(1, 0, 1);
                cubeGeometry.faces[7].vertexColors[2] = new THREE.Color(1, 0, 0);
                //right
                cubeGeometry.faces.push(new THREE.Face3(1, 6, 5));
                cubeGeometry.faces[8].vertexColors[0] = new THREE.Color(0, 1, 0);
                cubeGeometry.faces[8].vertexColors[1] = new THREE.Color(1, 1, 1);
                cubeGeometry.faces[8].vertexColors[2] = new THREE.Color(0, 1, 1);
                cubeGeometry.faces.push(new THREE.Face3(1, 2, 6));
                cubeGeometry.faces[9].vertexColors[0] = new THREE.Color(0, 1, 0);
                cubeGeometry.faces[9].vertexColors[1] = new THREE.Color(1, 1, 0);
                cubeGeometry.faces[9].vertexColors[2] = new THREE.Color(1, 1, 1);
                //back
                cubeGeometry.faces.push(new THREE.Face3(5, 6, 7));
                cubeGeometry.faces[10].vertexColors[0] = new THREE.Color(0, 1, 1);
                cubeGeometry.faces[10].vertexColors[1] = new THREE.Color(1, 1, 1);
                cubeGeometry.faces[10].vertexColors[2] = new THREE.Color(1, 0, 1);
                cubeGeometry.faces.push(new THREE.Face3(5, 7, 4));
                cubeGeometry.faces[11].vertexColors[0] = new THREE.Color(0, 1, 1);
                cubeGeometry.faces[11].vertexColors[1] = new THREE.Color(1, 0, 1);
                cubeGeometry.faces[11].vertexColors[2] = new THREE.Color(0, 0, 1);

                return cubeGeometry;
            }

            function baseFrontCube(cubeGeometry) {
                var cubeMaterial = new THREE.MeshBasicMaterial({
                    side: THREE.FrontSide,
                    vertexColors: THREE.VertexColors
                });

                return new THREE.Mesh(cubeGeometry, cubeMaterial);
            }

            function baseBackCube(cubeGeometry) {
                var cubeMaterial = new THREE.MeshBasicMaterial({
                    side: THREE.BackSide,
                    vertexColors: THREE.VertexColors
                });

                return new THREE.Mesh(cubeGeometry, cubeMaterial);
            }

            function rayCube(cubeGeometry, imagesOnSide) {
                var shaderMaterial = returnMaterialVolumeXray();

                return new THREE.Mesh(cubeGeometry, shaderMaterial);
            }

            function returnMaterialVolumeXray() {
                var baseUniforms = {
                    frontFace: { type: "t", value: frontTexture },
                    backFace: { type: "t", value: backTexture },
                    volume1: { type: "t", value: volumeTexture[0] },
                    volume2: { type: "t", value: volumeTexture[1] },
                    volume3: { type: "t", value: volumeTexture[2] },
                    volume4: { type: "t", value: volumeTexture[3] },
                    size: { type: "v2", value: new THREE.Vector2(WIDTH, HEIGHT) },
                    alphaMultiplier: { type: "f", value: alphaMul },
                    cntInRow: { type: "i", value: sideImgCount },
                    step: { type: "f", value: rayCastStep },
                    zSize: { type: "f", value: sizeInZ }
                };
                var shaderMaterial =
                new THREE.ShaderMaterial({
                    uniforms: baseUniforms,
                    vertexShader: document.getElementById('vertexshader').innerHTML,
                    fragmentShader: document.getElementById('xrayfshader').innerHTML
                });

                return shaderMaterial;
            }

            function returnMaterialVolumeLUT() {
                var uniforms = {
                    frontFace: { type: "t", value: frontTexture },
                    backFace: { type: "t", value: backTexture },
                    volume1: { type: "t", value: volumeTexture[0] },
                    volume2: { type: "t", value: volumeTexture[1] },
                    volume3: { type: "t", value: volumeTexture[2] },
                    volume4: { type: "t", value: volumeTexture[3] },
                    transferFce: { type: "t", value: lutTexture },
                    size: { type: "v2", value: new THREE.Vector2(WIDTH, HEIGHT) },
                    alphaMultiplier: { type: "f", value: alphaMul },
                    cntInRow: { type: "i", value: sideImgCount },
                    step: { type: "f", value: rayCastStep },
                    zSize: { type: "f", value: sizeInZ },
                    texelSize: { type: "f", value: 1. / sizeOfTexture }
                };

                var shaderMaterial =
                new THREE.ShaderMaterial({
                    uniforms: uniforms,
                    vertexShader: document.getElementById('vertexshader').innerHTML,
                    fragmentShader: document.getElementById('lutfshader').innerHTML
                });

                return shaderMaterial;
            }

            function returnMaterialVolumeMip() {
                var baseUniforms = {
                    frontFace: { type: "t", value: frontTexture },
                    backFace: { type: "t", value: backTexture },
                    volume1: { type: "t", value: volumeTexture[0] },
                    volume2: { type: "t", value: volumeTexture[1] },
                    volume3: { type: "t", value: volumeTexture[2] },
                    volume4: { type: "t", value: volumeTexture[3] },
                    size: { type: "v2", value: new THREE.Vector2(WIDTH, HEIGHT) },
                    alphaMultiplier: { type: "f", value: alphaMul },
                    cntInRow: { type: "i", value: sideImgCount },
                    step: { type: "f", value: rayCastStep },
                    zSize: { type: "f", value: sizeInZ }
                };
                var shaderMaterial =
                new THREE.ShaderMaterial({
                    uniforms: baseUniforms,
                    vertexShader: document.getElementById('vertexshader').innerHTML,
                    fragmentShader: document.getElementById('mipfshader').innerHTML
                });

                return shaderMaterial;
            }

            function returnMaterialVolumeIso() {
                var baseUniforms = {
                    frontFace: { type: "t", value: frontTexture },
                    backFace: { type: "t", value: backTexture },
                    volume1: { type: "t", value: volumeTexture[0] },
                    volume2: { type: "t", value: volumeTexture[1] },
                    volume3: { type: "t", value: volumeTexture[2] },
                    volume4: { type: "t", value: volumeTexture[3] },
                    size: { type: "v2", value: new THREE.Vector2(WIDTH, HEIGHT) },
                    alphaMultiplier: { type: "f", value: alphaMul },
                    cntInRow: { type: "i", value: sideImgCount },
                    step: { type: "f", value: rayCastStep },
                    zSize: { type: "f", value: sizeInZ },
                    textureSide: { type: "i", value: sizeOfTexture },
                    texelSize: { type: "f", value: 1. / sizeOfTexture }
                }; 

                var shaderMaterial =
                new THREE.ShaderMaterial({
                    uniforms: baseUniforms,
                    vertexShader: document.getElementById('vertexshader').innerHTML,
                    fragmentShader: document.getElementById('isofshader').innerHTML
                });

                return shaderMaterial;
            }

            function animate() {

                // Read more about requestAnimationFrame at http://www.paulirish.com/2011/requestanimationframe-for-smart-animating/
                if (isRunning)
                    requestAnimationFrame(animate);

                controls.update();

                // Render front cube.
                renderer.render(frontScene, camera, frontTexture, true);
                // Render back cube.
                renderer.render(backScene, camera, backTexture, true);

                //var c = document.getElementById("myCanvas");
                //var ctx = c.getContext("2d");
                //ctx.drawImage(new Image(frontTexture.), 10, 10);

                renderer.render(scene, camera);
            }

            function initWebGL(canvas) {
                gl = null;

                try {
                    // Try to grab the standard context. If it fails, fallback to experimental.
                    gl = canvas.getContext("webgl") || canvas.getContext("experimental-webgl");
                }
                catch (e) { }

                // If we don't have a GL context, give up now
                if (!gl) {
                    alert("Unable to initialize WebGL. Your browser may not support it.");
                    gl = null;
                }

                return gl;
            }
        </script>
    </body>
</html>