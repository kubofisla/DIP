<!DOCTYPE html> 
<html lang="en">
	<head>
		<title>three.js webgl - cameras</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    </head>
    <body>

        <!--<img src="lut/myLut3.png" alt="Smiley face" height="256" width="256">-->
        <div style="text-align: center; display:block;">
            <select style="display:table-cell;
                vertical-align:middle; margin:auto;" id="DateSetSelect" onchange="setDataset(this.value)">
                <option value="2">Hlava</option>
                <option value="1">Ladviny</option>
                <option value="3">Torso</option>
                <!--<option value="4">Light hard tissue</option>-->
            </select>
            <select style="display:table-cell;
                vertical-align:middle; margin:auto;" id="LutSelect" onchange="setLUT(this.value)">
                <option value="4">Light hard tissue</option>
                <option value="1">Muscle</option>
                <option value="2">Light muscle</option>
                <option value="3">Hard tissue</option>
            </select>
            <select style="display:table-cell;
                vertical-align:middle; margin:auto;" id="ShaderType" onchange="makeAnimate()"> <!--onchange="setShader()">-->
                <option value="xray">X-Ray</option>
                <option value="render">Render</option>
                <option value="mip">MIP</option>
                <option value="iso">Iso-surface</option>
            </select>
            <select style="display:table-cell;
                vertical-align:middle; margin:auto;" disabled="true" id="QualitySelect" onchange="changeQuality(this.value)">
                <option value="1">High</option>
                <option value="2">Medium</option>
                <option value="3">Low</option>
            </select>
            <input name="OpacityBar" type="range" id="sliderBar" min="0" max="100" step="1" value="50" onChange="setOpacity(this.value);" />
            <label><input type='checkbox' onclick='setBackground(this);'>Debug background</label>
            <input name="TrasholdBar" type="range" id="sliderBar" min="0" max="100" step="1" value="5" onChange="trasholdChange(this.value);" /> <label id="TrasholdLabel">Dens. trashold</label>
            <input name="CuttingPlaneBar" type="range" id="cutPlaneSliderBar" min="0" max="300" step="0.1" value="10" onChange="cutPlaneDistanceChange(this.value);" /> <label id="CutPlaneLabel">Cut Plane distance</label>
        </div>
        
        <div id="output"></div>
        
        <canvas id="myCanvas" style="display: block; border:1px solid #d3d3d3; color: black;"></canvas> 

        <script type="text/javascript">
            var alphaMulOneP = 0.000026;
            var alphaMul = 0.0013;
            var intensityT = 0.05;

            function setOpacity(opacity) {
                alphaMul = opacity * alphaMulOneP;
                //setShader();
                animate();
            }

            function makeAnimate() {
                animate();
            }

            function trasholdChange(density) {
                intensityT = density / 100.;
                document.getElementById('TrasholdLabel').innerHTML = intensityT.toFixed(2);
                //setShader();
                animate();
            }

            function cutPlaneDistanceChange(distance) {
                var cutPlaneDistance = distance / 100.;
                camera.near = cutPlaneDistance;
                camera.updateProjectionMatrix();
                document.getElementById('CutPlaneLabel').innerHTML = cutPlaneDistance.toFixed(2);
                //setShader();
                animate();
            }

            function setBackground(cb) {
                if (cb.checked)
                    renderer.setClearColor(0x333F47);
                else
                    renderer.setClearColor(0x000000);
            }

            function setShader() {
                var e = document.getElementById("ShaderType");
                var type = e.options[e.selectedIndex].value;

                if (type == "render")
                    volumeCube.material = returnMaterialVolumeLUT();
                else if (type == "xray")
                    volumeCube.material = returnMaterialVolumeXray();
                else if (type == "mip")
                    volumeCube.material = returnMaterialVolumeMip();
                else if (type == "iso")
                    volumeCube.material = returnMaterialVolumeIso();
                //animate();
            }

            function setLUT(lutNo) {
                if (lutNo == "1")
                    lutTexture = loader.load("lut/myLut1.png", function myfunction(texture) {
                        lutTexture = texture;
                        //setShader();
                        animate();
                    });
                else if (lutNo == "2")
                    lutTexture = loader.load("lut/myLut2.png", function myfunction(texture) {
                        lutTexture = texture;
                        //setShader();
                        animate();
                    });
                else if (lutNo == "3")
                    lutTexture = loader.load("lut/myLut3.png", function myfunction(texture) {
                        lutTexture = texture;
                        //setShader();
                        animate();
                    });
                else if (lutNo == "4")
                    lutTexture = loader.load("lut/myLut4.png", function myfunction(texture) {
                        lutTexture = texture;
                        //setShader();
                        animate();
                    });
            }

            function setDataset(dsNo) {
                if (dsNo == "1") {
                    volumeTexture = oblickyTexture;
                    sizeInZ = 0.002;
                }
                else if (dsNo == "2") {
                    volumeTexture = hlavaTexture;
                    sizeInZ = 0.007;
                }
                else if (dsNo == "3") {
                    volumeTexture = torsoTexture;
                    sizeInZ = 0.0028;
                }
                //setShader();
                animate();
            }

            function changeQuality(settNo) {
                if(settNo == "1") {
                    sizeOfTexture = 8192;
                    sizeOfImage = 512;
                    rayCastStep = 0.0005;
                    alphaMul = 0.0013;
                    alphaMulOneP = 0.000026;
                    sideImgCount = parseInt(sizeOfTexture / sizeOfImage, 10);
                }
                else if (settNo == "2") {
                    sizeOfTexture = 4096;
                    sizeOfImage = 256;
                    rayCastStep = 0.0015;
                    alphaMul = 0.004;
                    alphaMulOneP = 0.00008;
                    sideImgCount = parseInt(sizeOfTexture / sizeOfImage, 10);
                }
                else if (settNo == "3") {
                    sizeOfTexture = 1024;
                    sizeOfImage = 128;
                    rayCastStep = 0.0025;
                    alphaMul = 0.008;
                    alphaMulOneP = 0.00016;
                    sideImgCount = parseInt(sizeOfTexture / sizeOfImage, 10);
                }
                hlavaTexture = preprocessData("volumes/HEAD/",  83, 0);
                oblickyTexture = preprocessData("volumes/SET1/",  361, 1);
                torsoTexture = preprocessData("volumes/TORSO/",  394, 2);

                var e = document.getElementById("DateSetSelect");
                var type = e.options[e.selectedIndex].value;
                setDataset(type)
            }
        </script>

        <script src="./js/three.js"></script>
        <script src="./js/OrbitControls.js"></script>
        <script src="./DataProcessing.js"></script>
        <script src="./CutPlane.js"></script>

        <!-- Shaders -->
        <script type="x-shader/x-vertex" id="vertexshader">

            // switch on high precision floats

            void main()
            {
                gl_Position = projectionMatrix * modelViewMatrix * vec4(position,1.0);
            }

        </script>

        <script type="x-shader/x-fragment" id="xrayfshader">

            #ifdef GL_ES
            precision highp float;
            #endif

            uniform sampler2D frontFace;
            uniform sampler2D backFace;

            uniform sampler2D volume1;
            uniform sampler2D volume2;
            uniform sampler2D volume3;
            uniform sampler2D volume4;

            uniform vec2 size;
            uniform float alphaMultiplier;
            uniform float step;
            uniform int cntInRow;
            uniform float zSize;
            vec3 direction;

            int textureIndex = 0;

            vec2 mappingFce(vec3 position, int sideCnt){
                float partSide = float(1) / float(sideCnt);

                int imgCount = int(position.z * (float(1) / zSize));

                int yMul = int(imgCount / sideCnt);
                int xMul = int(imgCount - (yMul*sideCnt));

                textureIndex = yMul/sideCnt;
                yMul -= textureIndex*sideCnt;

                float xPos = (position.x / float(sideCnt)) + (partSide * float(xMul));
                float yPos = (position.y / float(sideCnt)) + (partSide * float(yMul));

                return vec2(xPos, yPos);
            }

            vec4 getColor(vec2 pos){

                if(textureIndex == 0)
                   return texture2D(volume1, pos.xy);
                if(textureIndex == 1)
                    return texture2D(volume2, pos.xy);
                if(textureIndex == 2)
                    return texture2D(volume3, pos.xy);
                if(textureIndex == 3)
                    return texture2D(volume4, pos.xy);
                
                return vec4(0.);
            }
            
            vec4 getFilteredColor(vec3 position, float partSide){
                float zAxis = position.z * (float(1) / zSize);  
                int imgIndex = int(zAxis);
                
                float colorDiff = zAxis - float(imgIndex);
                float opositeColorDiff = 1. - colorDiff;

                int yOffset = imgIndex / cntInRow;
                //int xOffset = imgIndex - cntInRow * int(floor( float(imgIndex) / float(cntInRow) )); //modulo
                int xOffset = int(mod(float(imgIndex), float(cntInRow)));

                textureIndex = yOffset/cntInRow;
                yOffset -= textureIndex*cntInRow;

                float xPos = (position.x / float(cntInRow)) + (partSide * float(xOffset));
                float yPos = (position.y / float(cntInRow)) + (partSide * float(yOffset));

                vec4 color1 = getColor(vec2(xPos, yPos));

                float interpoledColor = color1.g*opositeColorDiff + color1.b*colorDiff;

                return vec4(interpoledColor,interpoledColor,interpoledColor,1.);
            }

            void main()
            {
                vec4 value;
                vec4 result = vec4(0.0);

                vec4 fragCoord = vec4(gl_FragCoord.xy/size, 0.0, 0.0);
                vec3 frontPos = texture2D(frontFace, fragCoord.xy).rgb;
                vec3 backPos = texture2D(backFace, fragCoord.xy).rgb;
                vec3 path = backPos - frontPos;
                direction = normalize(path);

                vec3 actualPos = frontPos;

                float partSide = float(1) / float(cntInRow);
                float alfa = 0.0;

                float rayDistance = length(path);
                float actualDistance = 0.;

                vec3 diff1 = direction * step;
                float vDiff1 = length(diff1);

                for (int i=0; i < 2000; i++) {

                    if(actualDistance > rayDistance || actualPos.x > 1.0 || actualPos.x < 0.0 || actualPos.y > 1.0 || actualPos.y < 0.0 || actualPos.z > 1.0 || actualPos.z < 0.0 )
                        break;

                    value = getFilteredColor(actualPos.xyz, partSide);
                    value.a = ((0.2126*value.r + 0.7152*value.g + 0.0722*value.b)*alphaMultiplier);
                    alfa += value.g * alphaMultiplier;
                    if(alfa >= 0.99)
                    {
                        alfa = 1.0;
                        break;
                    }
    
                    actualPos += diff1;
                    actualDistance += vDiff1;
                }

                gl_FragColor=vec4(vec3(1.0,1.0,1.0)*alfa, 1.0);
            }

        </script>

        <script type="x-shader/x-fragment" id="lutfshader">

            #ifdef GL_ES
            precision highp float;
            #endif

            uniform sampler2D frontFace;
            uniform sampler2D backFace;

            uniform sampler2D volume1;
            uniform sampler2D volume2;
            uniform sampler2D volume3;
            uniform sampler2D volume4;

            uniform sampler2D transferFce;

            uniform vec2 size;
            uniform float alphaMultiplier;
            uniform int cntInRow;
            uniform float step;
            uniform float zSize;
            uniform float texelSize;
            uniform vec3 lightPos;

            const float SpecularContribution = 0.0;
            const float DiffuseContribution = 1.0 - SpecularContribution;
            
            //vec3 lightPos = vec3(10., -10., -10.);
            
            float zCount;

            vec3 direction;
            int textureIndex = 0;
            float partSide;

            float actualIntensity;
            vec4 actualPoint;
            vec4 top, bottom, left, right;
            float xPos, yPos;

            int imgIndex;
            float colorDiff;
            float opositeColorDiff;

            float sizeTextelX;
            float sizeTextelY;
            
            vec4 getColor(vec2 pos){

                if(textureIndex == 0)
                   return texture2D(volume1, pos.xy);
                if(textureIndex == 1)
                    return texture2D(volume2, pos.xy);
                if(textureIndex == 2)
                    return texture2D(volume3, pos.xy);
                if(textureIndex == 3)
                    return texture2D(volume4, pos.xy);
                
                return vec4(0.);
            }

            void mappingFceActual(vec3 position){
                imgIndex = int(floor(position.z * zCount));
                
                int yOffset = imgIndex / cntInRow;
                int xOffset = imgIndex - (yOffset * cntInRow);

                textureIndex = yOffset/cntInRow;
                yOffset -= textureIndex*cntInRow;

                xPos = (position.x / float(cntInRow)) + (partSide * float(xOffset));
                yPos = (position.y / float(cntInRow)) + (partSide * float(yOffset));

                actualPoint = getColor(vec2(xPos, yPos));
            }

            void mappingFceEviroment(vec3 position){
                right = getColor(vec2(xPos + sizeTextelX, yPos));
                left = getColor(vec2(xPos - sizeTextelX, yPos));
                top = getColor(vec2(xPos, yPos + sizeTextelY));
                bottom = getColor(vec2(xPos, yPos - sizeTextelY));
            }

            float getFilteredColor(float color1, float color2){
                
                //return color1;
                return color1*opositeColorDiff + color2*colorDiff;
            }

            
            vec3 getActualNormal(){
                vec3 normal = vec3( getFilteredColor(right.g, right.b) - getFilteredColor(left.g, left.b),
                                    getFilteredColor(top.g, top.b) - getFilteredColor(bottom.g, bottom.b),
                                    getFilteredColor(actualPoint.r, actualPoint.g) - getFilteredColor(actualPoint.b, actualPoint.a));
                return normalize(normal);
            }

            float getLightIntensity(vec3 actualPos, vec3 normal){
                //vec3 lightVec = normalize(lightPos - actualPos);
                //float diffuse = max(dot(lightVec, normal), 0.3);

                vec3 lightVec = normalize(lightPos - actualPos);
                float diffuse = clamp(dot(lightVec, normal), 0.2, 1.);
                
                //Aj odraz  
                //vec3 viewVec = direction;
                //vec3 reflectVec = reflect(-lightVec, normal);
                //float spec = 0.0;
                //if (diffuse > 0.0){
                //spec = max(dot(reflectVec, viewVec), 0.2);
                //spec = pow(spec, 16.0);
                //}
                //return SpecularContribution*spec + DiffuseContribution*diffuse;
            
                return DiffuseContribution*diffuse;
            }

            void comupteColorDiff(vec3 actualPos){
                float zAxis = actualPos.z * zCount;
                int imgIndex = int(zAxis);

                colorDiff = zAxis - float(imgIndex);
                opositeColorDiff = 1. - colorDiff;
            }

            void main()
            {
                zCount = float(1) / zSize;

                vec4 value;
                vec4 result = vec4(0.0);

                vec2 fragCoord = gl_FragCoord.xy/size;
                vec3 frontPos = texture2D(frontFace, fragCoord).rgb;
                vec3 backPos = texture2D(backFace, fragCoord).rgb;
                vec3 path = backPos - frontPos;
                direction = normalize(path);
                
                sizeTextelX = texelSize;
                sizeTextelY = texelSize;
                    
                vec3 actualPos = frontPos;

                partSide = float(1) / float(cntInRow);

                float rayDistance = length(path);
                float actualDistance = 0.;

                vec3 diff1 = direction * step;
                float vDiff1 = length(diff1);

                float LightIntensity = 1.0;

                for (int i=0; i < 20000; i++) {

                    if(actualDistance > rayDistance || actualPos.x > 1.0 || actualPos.x < 0.0 || actualPos.y > 1.0 || actualPos.y < 0.0 || actualPos.z > 1.0 || actualPos.z < 0.0 )
                        break;
                        
                    mappingFceActual(actualPos);
                    comupteColorDiff(actualPos);
                        
                    actualIntensity = getFilteredColor(actualPoint.g, actualPoint.b);

                    if(actualIntensity > 0.01){
                        mappingFceEviroment(actualPos);
                        LightIntensity = getLightIntensity(actualPos, getActualNormal());
                        
                        value = texture2D(transferFce, vec2(actualIntensity, 0.5));
                        value.rgb = clamp(value.rgb *  LightIntensity + value.rgb * 0.05, 0., 1.);

                        if(value.a < 0.9)
                            value.a *= alphaMultiplier*125.;

                        result.rgb = (1.0 - result.a) * value.rgb * value.a + result.rgb;
                        result.a = (1.0 - result.a) * value.a + result.a;

                        if(result.a >= 0.99)
                        {
                            result.a = 1.0;
                            break;
                        }
                    }

                    actualPos += diff1;
                    actualDistance += vDiff1;
                }
                gl_FragColor = result;
            }

        </script>

        <script type="x-shader/x-fragment" id="mipfshader">

            #ifdef GL_ES
            precision highp float;
            #endif

            uniform sampler2D frontFace;
            uniform sampler2D backFace;

            uniform sampler2D volume1;
            uniform sampler2D volume2;
            uniform sampler2D volume3;
            uniform sampler2D volume4;

            uniform vec2 size;
            uniform float alphaMultiplier;
            uniform int cntInRow;
            uniform float step;
            uniform float zSize;
            vec3 direction;

            int textureIndex = 0;

            vec2 mappingFce(vec3 position, int sideCnt){
                float partSide = float(1) / float(sideCnt);

                int imgCount = int(position.z * (float(1) / zSize));

                int yMul = int(imgCount / sideCnt);
                int xMul = int(imgCount - (yMul*sideCnt));

                textureIndex = yMul/sideCnt;
                yMul -= textureIndex*sideCnt;

                float xPos = (position.x / float(sideCnt)) + (partSide * float(xMul));
                float yPos = (position.y / float(sideCnt)) + (partSide * float(yMul));

                return vec2(xPos, yPos);
            }

            vec4 getColor(vec2 pos){

                if(textureIndex == 0)
                   return texture2D(volume1, pos.xy);
                if(textureIndex == 1)
                    return texture2D(volume2, pos.xy);
                if(textureIndex == 2)
                    return texture2D(volume3, pos.xy);
                if(textureIndex == 3)
                    return texture2D(volume4, pos.xy);
                
                return vec4(0.);
            }

            vec4 getFilteredColor(vec3 position, float partSide){
                float zAxis = position.z * (float(1) / zSize);  
                int imgIndex = int(zAxis);
                
                float colorDiff = zAxis - float(imgIndex);
                float opositeColorDiff = 1. - colorDiff;

                int yOffset = imgIndex / cntInRow;
                //int xOffset = imgIndex - cntInRow * int(floor( float(imgIndex) / float(cntInRow) )); //modulo
                int xOffset = int(mod(float(imgIndex), float(cntInRow)));

                textureIndex = yOffset/cntInRow;
                yOffset -= textureIndex*cntInRow;

                float xPos = (position.x / float(cntInRow)) + (partSide * float(xOffset));
                float yPos = (position.y / float(cntInRow)) + (partSide * float(yOffset));

                vec4 color1 = getColor(vec2(xPos, yPos));

                float interpoledColor = color1.g*opositeColorDiff + color1.b*colorDiff;

                return vec4(interpoledColor,interpoledColor,interpoledColor,1.);
            }
            
            void main()
            {
                float am = alphaMultiplier/0.004;

                vec4 value = vec4(0.0);

                vec2 fragCoord = gl_FragCoord.xy/size;
                vec3 frontPos = texture2D(frontFace, fragCoord).rgb;
                vec3 backPos = texture2D(backFace, fragCoord).rgb;
                vec3 path = backPos - frontPos;
                direction = normalize(path);

                vec3 actualPos = frontPos;

                float partSide = float(1) / float(cntInRow);

                float rayDistance = length(path);
                float actualDistance = 0.;

                vec3 diff1 = direction * step;
                float vDiff1 = length(diff1);

                for (int i=0; i < 2000; i++) {

                    if(actualDistance > rayDistance || actualPos.x > 1.0 || actualPos.x < 0.0 || actualPos.y > 1.0 || actualPos.y < 0.0 || actualPos.z > 1.0 || actualPos.z < 0.0 )
                        break;

                    vec4 v = getFilteredColor(actualPos.xyz, partSide);
                        
                    if(v.g > value.g)
                    {
                        value = v;
                    }
                        
                    actualPos += diff1;
                    actualDistance += vDiff1;
                }

                gl_FragColor = vec4(value.g, value.g, value.g, 1.);
            }

        </script>

        <script type="x-shader/x-fragment" id="isofshader">

            #ifdef GL_ES
            precision highp float;
            #endif

            uniform sampler2D frontFace;
            uniform sampler2D backFace;

            uniform sampler2D volume1;
            uniform sampler2D volume2;
            uniform sampler2D volume3;
            uniform sampler2D volume4;

            uniform vec2 size;
            uniform float alphaMultiplier;
            uniform int cntInRow;
            uniform float step;
            uniform float zSize;
            uniform int textureSide;
            uniform float texelSize;
            
            uniform float intensityTreshold;
            uniform vec3 lightPos;

            const float SpecularContribution = 0.0;
            const float DiffuseContribution = 1.0 - SpecularContribution;
            //const vec3 lightPos = vec3(10., -10., -10.);
            
            float zCount;

            vec3 direction;
            int textureIndex = 0;
            float partSide;

            float actualIntensity;
            vec4 actualPoint;
            vec4 top, bottom, left, right;

            float xPos, yPos;

            int imgIndex;
            float colorDiff;
            float opositeColorDiff;

            float sizeTextelX;
            float sizeTextelY;
            
            vec4 getColor(vec2 pos){

                if(textureIndex == 0)
                   return texture2D(volume1, pos.xy);
                if(textureIndex == 1)
                    return texture2D(volume2, pos.xy);
                if(textureIndex == 2)
                    return texture2D(volume3, pos.xy);
                if(textureIndex == 3)
                    return texture2D(volume4, pos.xy);
                
                return vec4(0.);
            }

            vec4 mappingFceActual(vec3 position){
                imgIndex = int(floor(position.z * zCount));
                
                int yOffset = imgIndex / cntInRow;
                int xOffset = imgIndex - (yOffset * cntInRow);

                textureIndex = yOffset/cntInRow;
                yOffset -= textureIndex*cntInRow;

                xPos = (position.x / float(cntInRow)) + (partSide * float(xOffset));
                yPos = (position.y / float(cntInRow)) + (partSide * float(yOffset));

                actualPoint = getColor(vec2(xPos, yPos));

                //yOffset = (imgIndex+1) / cntInRow;
                //xOffset = (imgIndex+1) - (yOffset * cntInRow);

                //int textureIndex2 = yOffset/cntInRow;
                //yOffset -= textureIndex2*cntInRow;

                //float xPos2 = (position.x / float(cntInRow)) + (partSide * float(xOffset));
                //float yPos2 = (position.y / float(cntInRow)) + (partSide * float(yOffset));

                //vec2 pos = vec2(xPos2, yPos2);

                //if(textureIndex2 == 0)
                //    return texture2D(volume1, pos.xy);
                //if(textureIndex2 == 1)
                //    return texture2D(volume2, pos.xy);
                //if(textureIndex2 == 2)
                //    return texture2D(volume3, pos.xy);
                //if(textureIndex2 == 3)
                //    return texture2D(volume4, pos.xy);

                return vec4(0.);
            }

            void mappingFceEviroment(vec3 position){
                right = getColor(vec2(xPos + sizeTextelX, yPos));
                left = getColor(vec2(xPos - sizeTextelX, yPos));
                top = getColor(vec2(xPos, yPos + sizeTextelY));
                bottom = getColor(vec2(xPos, yPos - sizeTextelY));
            }

            float getFilteredColor(float color1, float color2){
                
                //return color1;
                return color1*opositeColorDiff + color2*colorDiff;
            }

            
            vec3 getActualNormal(){
                vec3 normal = vec3( getFilteredColor(right.g, right.b) - getFilteredColor(left.g, left.b),
                                    getFilteredColor(top.g, top.b) - getFilteredColor(bottom.g, bottom.b),
                                    getFilteredColor(actualPoint.r, actualPoint.g) - getFilteredColor(actualPoint.b, actualPoint.a));
                return normalize(normal);
            }

            float getLightIntensity(vec3 actualPos, vec3 normal){
                vec3 lightVec = normalize(lightPos - actualPos);
                float diffuse = clamp(dot(lightVec, normal), 0.2, 1.);
                
                //vec3 lightVec = normalize(lightPos - actualPos);
                //float diffuse = max(dot(lightVec, normal), 0.3);
            
                //Aj odraz  
                //vec3 viewVec = direction;
                //vec3 reflectVec = reflect(-lightVec, normal);
                //float spec = 0.0;
                //if (diffuse > 0.0){
                //spec = max(dot(reflectVec, viewVec), 0.2);
                //spec = pow(spec, 16.0);
                //}
                //return SpecularContribution*spec + DiffuseContribution*diffuse;
            
                return DiffuseContribution*diffuse;
            }

            void comupteColorDiff(vec3 actualPos){
                float zAxis = actualPos.z / zSize;

                colorDiff = zAxis - floor(zAxis);
                //colorDiff = 1.;
                opositeColorDiff = 1. - colorDiff;
            }

            void main()
            {
                zCount = float(1) / zSize;
                partSide = float(1) / float(cntInRow);
                
                vec4 value = vec4(0.0);
                float Idiff = 0.;

                vec2 fragCoord = gl_FragCoord.xy/size;
                vec3 frontPos = texture2D(frontFace, fragCoord).rgb;
                vec3 backPos = texture2D(backFace, fragCoord).rgb;
                vec3 path = backPos - frontPos;
                direction = normalize(path);

                vec3 isoColor = vec3(0.004*245., 0.004*228., 0.004*203.);

                vec3 actualPos = frontPos;
                
                sizeTextelX = texelSize;
                sizeTextelY = texelSize;

                float rayDistance = length(path);
                float actualDistance = 0.;

                vec3 diff1 = direction * step;
                float vDiff1 = length(diff1);

                float LightIntensity = 1.0;

                for (int i=0; i < 2000; i++) {

                    if(actualDistance > rayDistance || actualPos.x > 1.0 || actualPos.x < 0.0 || actualPos.y > 1.0 || actualPos.y < 0.0 || actualPos.z > 1.0 || actualPos.z < 0.0 )
                        break;

                    vec4 nextPoint = mappingFceActual(actualPos);
                    comupteColorDiff(actualPos);

                    actualIntensity = getFilteredColor(actualPoint.y, actualPoint.z);

                    if(actualIntensity > intensityTreshold)
                    {
                        //value.rgb = isoColor * actualIntensity;
                        //shading
                        mappingFceEviroment(actualPos);
                        Idiff = getLightIntensity(actualPos, getActualNormal());
                            
                        
                        //value.rgb = isoColor;
                        value.rgb = clamp(isoColor * Idiff + isoColor * 0.05, 0., 1.);
                        value.a = 1.;

                        break;
                    }
                        
                    actualPos += diff1;
                    actualDistance += vDiff1;
                }
                gl_FragColor = value;
            }

        </script>

        <script>
            function SetupRenderEvents(canvas) {
                canvas.onmousedown = function (e) {
                    startLoop(true);
                }
                canvas.onmouseup = function (e) {
                    startLoop(false);
                }

                var mousewheelevt = (/Firefox/i.test(navigator.userAgent)) ? "DOMMouseScroll" : "mousewheel" //FF doesn't recognize mousewheel as of FF3.x

                if (canvas.attachEvent) //if IE (and Opera depending on user setting)
                    canvas.attachEvent("on" + mousewheelevt, zoomSceneRedraw)
                else if (canvas.addEventListener) //WC3 browsers
                    canvas.addEventListener(mousewheelevt, zoomSceneRedraw, false)

                function zoomSceneRedraw(e) {
                    startLoop(true);
                    startLoop(false);
                }
            }
        </script>

        <script>
            var isRunning = false;

            var scene, frontScene, backScene;
            var camera, renderer, backRenderer, frontRenderer;
            var controls;
            var WIDTH,
                HEIGHT;
            var gl;
            var volumeCube;
            var cuttingPlane;
            var planeObject, rayPlaneObject;

            var sizeOfTexture = 4096;
            var sizeOfImage = 256;
            var rayCastStep = 0.0015;
            //var sizeOfTexture = 8192;
            //var sizeOfImage = 512;
            //var rayCastStep = 0.0005;
            alphaMul = 0.004;
            alphaMulOneP = 0.00008;
            var sizeInZ = 0.007;
            var sideImgCount = parseInt(sizeOfTexture / sizeOfImage, 10);
            var loader;
            var frontTexture, backTexture, volumeTexture, lutTexture;
            var oblickyTexture, hlavaTexture;
            var isLoaded = [false, false, false];
            var dataImages = new Array(3);

            document.getElementById("QualitySelect").selectedIndex = 1;

            init();
            animate();

            function startLoop(state) {

                if (state && !isRunning) {
                    isRunning = true;
                    animate();             /// starts loop

                } else if (!state && isRunning) {
                    isRunning = false;
                }
            }

            function init() {
                for (i = 0; i < 3; i++) {
                    dataImages[i] = new Array(512);
                }

                // Create the scene and set the scene size.
                scene = new THREE.Scene();
                frontScene = new THREE.Scene();
                backScene = new THREE.Scene();

                WIDTH = 800;
                HEIGHT = 600;

                // Create a renderer and add it to the DOM.
                renderer = new THREE.WebGLRenderer({ antialias: true });
                renderer.setSize(WIDTH, HEIGHT);
                renderer.setPixelRatio(window.devicePixelRatio);
                renderer.autoClear = false;
                document.getElementById("output").appendChild(renderer.domElement);

                var canvas = renderer.domElement;
                SetupRenderEvents(canvas);

                // Initialize the GL context
                gl = initWebGL(canvas);

                // Create a camera, zoom it out from the model a bit, and add it to the scene.
                camera = new THREE.PerspectiveCamera(
                  35,         // Field of view
                  WIDTH / HEIGHT,  // Aspect ratio
                  .1,         // Near
                  10000       // Far
                );
                camera.position.set(2, 2, 2);
                frontScene.add(camera);
                backScene.add(camera);
                scene.add(camera);

                // Create an event listener that resizes the renderer with the browser window.
                window.addEventListener('resize', function () {
                    renderer.setSize(WIDTH, HEIGHT);
                    camera.aspect = WIDTH / HEIGHT;
                    camera.updateProjectionMatrix();
                });

                // Set the background color of the scene.
                renderer.setClearColor(0x000000, 0);
                // Add OrbitControls so that we can pan around with the mouse.
                controls = new THREE.OrbitControls(camera, renderer.domElement);
                //Nastavi pohlad kamery do stredu kocky
                controls.target.set(0.5, 0.5, 0.5);

                //LUT image
                loader = new THREE.TextureLoader()
                lutTexture = loader.load("lut/myLut4.png");
                
                //Load dataset
                hlavaTexture = preprocessData("volumes/HEAD/",  83, 0);
                oblickyTexture = preprocessData("volumes/SET1/",  361, 1);
                torsoTexture = preprocessData("volumes/TORSO/",  394, 2);
                volumeTexture = hlavaTexture;
                //volumeTexture = new THREE.Texture();
                //changeQuality("2");

                //Trieda na cutting plane
                cuttingPlane = new CutPlane(camera, controls);

                //Create cube
                var frontCube = baseFrontCube(createCubeGeometry());
                var backCube = baseBackCube(createCubeGeometry());
                frontScene.add(frontCube);
                backScene.add(backCube);

                frontTexture = new THREE.WebGLRenderTarget(WIDTH, HEIGHT, { minFilter: THREE.LinearFilter, magFilter: THREE.LinearMipMapNearestFilter, format: THREE.RGBFormat, type: THREE.HalfFloatType });
                backTexture = new THREE.WebGLRenderTarget(WIDTH, HEIGHT, { minFilter: THREE.LinearFilter, magFilter: THREE.LinearMipMapNearestFilter, format: THREE.RGBFormat, type: THREE.HalfFloatType });

                volumeCube = rayCube(createCubeGeometry(), sideImgCount);
                //scene.add(frontCube);
                scene.add(volumeCube);

                //var planeGeometry = cuttingPlane.cutBox();
                //planeObject = baseFrontCube(planeGeometry);
                //scene.add(planeObject);
            }


            function createCubeGeometry() {
                //load geometry
                var cubeGeometry = new THREE.Geometry();

                //add vertices
                cubeGeometry.vertices.push(new THREE.Vector3(0.0, 0.0, 1.0));//0
                cubeGeometry.vertices.push(new THREE.Vector3(0.0, 1.0, 1.0));//1
                cubeGeometry.vertices.push(new THREE.Vector3(1.0, 1.0, 1.0));//2
                cubeGeometry.vertices.push(new THREE.Vector3(1.0, 0.0, 1.0));//3
                cubeGeometry.vertices.push(new THREE.Vector3(0.0, 0.0, 0.0));//4
                cubeGeometry.vertices.push(new THREE.Vector3(0.0, 1.0, 0.0));//5
                cubeGeometry.vertices.push(new THREE.Vector3(1.0, 1.0, 0.0));//6
                cubeGeometry.vertices.push(new THREE.Vector3(1.0, 0.0, 0.0));//7

                cuttingPlane.setLines([]);
                //hrany kocky, pre testovanie prienikov
                cuttingPlane.addLine(new THREE.Line3(cubeGeometry.vertices[0], cubeGeometry.vertices[1]));
                cuttingPlane.addLine(new THREE.Line3(cubeGeometry.vertices[1], cubeGeometry.vertices[2]));
                cuttingPlane.addLine(new THREE.Line3(cubeGeometry.vertices[2], cubeGeometry.vertices[3]));
                cuttingPlane.addLine(new THREE.Line3(cubeGeometry.vertices[3], cubeGeometry.vertices[0]));

                cuttingPlane.addLine(new THREE.Line3(cubeGeometry.vertices[0], cubeGeometry.vertices[4]));
                cuttingPlane.addLine(new THREE.Line3(cubeGeometry.vertices[1], cubeGeometry.vertices[5]));
                cuttingPlane.addLine(new THREE.Line3(cubeGeometry.vertices[2], cubeGeometry.vertices[6]));
                cuttingPlane.addLine(new THREE.Line3(cubeGeometry.vertices[3], cubeGeometry.vertices[7]));

                cuttingPlane.addLine(new THREE.Line3(cubeGeometry.vertices[4], cubeGeometry.vertices[5]));
                cuttingPlane.addLine(new THREE.Line3(cubeGeometry.vertices[5], cubeGeometry.vertices[6]));
                cuttingPlane.addLine(new THREE.Line3(cubeGeometry.vertices[6], cubeGeometry.vertices[7]));
                cuttingPlane.addLine(new THREE.Line3(cubeGeometry.vertices[7], cubeGeometry.vertices[4]));
                //cuttingPlane.addLine(new THREE.Line3(new THREE.Vector3(0, 50, 0), new THREE.Vector3(0, -50, 0)));

                //front
                cubeGeometry.faces.push(new THREE.Face3(0, 2, 1));
                cubeGeometry.faces[0].vertexColors[0] = new THREE.Color(0, 0, 0);
                cubeGeometry.faces[0].vertexColors[1] = new THREE.Color(1, 1, 0);
                cubeGeometry.faces[0].vertexColors[2] = new THREE.Color(0, 1, 0);
                cubeGeometry.faces.push(new THREE.Face3(0, 3, 2));
                cubeGeometry.faces[1].vertexColors[0] = new THREE.Color(0, 0, 0);
                cubeGeometry.faces[1].vertexColors[1] = new THREE.Color(1, 0, 0);
                cubeGeometry.faces[1].vertexColors[2] = new THREE.Color(1, 1, 0);
                //bot
                cubeGeometry.faces.push(new THREE.Face3(0, 1, 4));
                cubeGeometry.faces[2].vertexColors[0] = new THREE.Color(0, 0, 0);
                cubeGeometry.faces[2].vertexColors[1] = new THREE.Color(0, 1, 0);
                cubeGeometry.faces[2].vertexColors[2] = new THREE.Color(0, 0, 1);
                cubeGeometry.faces.push(new THREE.Face3(1, 5, 4));
                cubeGeometry.faces[3].vertexColors[0] = new THREE.Color(0, 1, 0);
                cubeGeometry.faces[3].vertexColors[1] = new THREE.Color(0, 1, 1);
                cubeGeometry.faces[3].vertexColors[2] = new THREE.Color(0, 0, 1);
                //top
                cubeGeometry.faces.push(new THREE.Face3(2, 7, 6));
                cubeGeometry.faces[4].vertexColors[0] = new THREE.Color(1, 1, 0);
                cubeGeometry.faces[4].vertexColors[1] = new THREE.Color(1, 0, 1);
                cubeGeometry.faces[4].vertexColors[2] = new THREE.Color(1, 1, 1);
                cubeGeometry.faces.push(new THREE.Face3(3, 7, 2));
                cubeGeometry.faces[5].vertexColors[0] = new THREE.Color(1, 0, 0);
                cubeGeometry.faces[5].vertexColors[1] = new THREE.Color(1, 0, 1);
                cubeGeometry.faces[5].vertexColors[2] = new THREE.Color(1, 1, 0);
                //left
                cubeGeometry.faces.push(new THREE.Face3(0, 4, 7));
                cubeGeometry.faces[6].vertexColors[0] = new THREE.Color(0, 0, 0);
                cubeGeometry.faces[6].vertexColors[1] = new THREE.Color(0, 0, 1);
                cubeGeometry.faces[6].vertexColors[2] = new THREE.Color(1, 0, 1);
                cubeGeometry.faces.push(new THREE.Face3(0, 7, 3));
                cubeGeometry.faces[7].vertexColors[0] = new THREE.Color(0, 0, 0);
                cubeGeometry.faces[7].vertexColors[1] = new THREE.Color(1, 0, 1);
                cubeGeometry.faces[7].vertexColors[2] = new THREE.Color(1, 0, 0);
                //right
                cubeGeometry.faces.push(new THREE.Face3(1, 6, 5));
                cubeGeometry.faces[8].vertexColors[0] = new THREE.Color(0, 1, 0);
                cubeGeometry.faces[8].vertexColors[1] = new THREE.Color(1, 1, 1);
                cubeGeometry.faces[8].vertexColors[2] = new THREE.Color(0, 1, 1);
                cubeGeometry.faces.push(new THREE.Face3(1, 2, 6));
                cubeGeometry.faces[9].vertexColors[0] = new THREE.Color(0, 1, 0);
                cubeGeometry.faces[9].vertexColors[1] = new THREE.Color(1, 1, 0);
                cubeGeometry.faces[9].vertexColors[2] = new THREE.Color(1, 1, 1);
                //back
                cubeGeometry.faces.push(new THREE.Face3(5, 6, 7));
                cubeGeometry.faces[10].vertexColors[0] = new THREE.Color(0, 1, 1);
                cubeGeometry.faces[10].vertexColors[1] = new THREE.Color(1, 1, 1);
                cubeGeometry.faces[10].vertexColors[2] = new THREE.Color(1, 0, 1);
                cubeGeometry.faces.push(new THREE.Face3(5, 7, 4));
                cubeGeometry.faces[11].vertexColors[0] = new THREE.Color(0, 1, 1);
                cubeGeometry.faces[11].vertexColors[1] = new THREE.Color(1, 0, 1);
                cubeGeometry.faces[11].vertexColors[2] = new THREE.Color(0, 0, 1);

                return cubeGeometry;
            }

            function baseFrontCube(cubeGeometry) {
                var cubeMaterial = new THREE.MeshBasicMaterial({
                    side: THREE.DoubleSide,
                    vertexColors: THREE.VertexColors
                });

                return new THREE.Mesh(cubeGeometry, cubeMaterial);
            }

            function baseBackCube(cubeGeometry) {
                var cubeMaterial = new THREE.MeshBasicMaterial({
                    side: THREE.BackSide,
                    vertexColors: THREE.VertexColors
                });

                return new THREE.Mesh(cubeGeometry, cubeMaterial);
            }

            function rayCube(cubeGeometry, imagesOnSide) {
                var e = document.getElementById("ShaderType");
                var type = e.options[e.selectedIndex].value;

                if (type == "render")
                    shaderMaterial = returnMaterialVolumeLUT();
                else if (type == "xray")
                    shaderMaterial = returnMaterialVolumeXray();
                else if (type == "mip")
                    shaderMaterial = returnMaterialVolumeMip();
                else if (type == "iso")
                    shaderMaterial = returnMaterialVolumeIso();

                return new THREE.Mesh(cubeGeometry, shaderMaterial);
            }

            function returnMaterialVolumeXray() {
                var baseUniforms = {
                    frontFace: { type: "t", value: frontTexture },
                    backFace: { type: "t", value: backTexture },
                    volume1: { type: "t", value: volumeTexture[0] },
                    volume2: { type: "t", value: volumeTexture[1] },
                    volume3: { type: "t", value: volumeTexture[2] },
                    volume4: { type: "t", value: volumeTexture[3] },
                    size: { type: "v2", value: new THREE.Vector2(WIDTH, HEIGHT) },
                    alphaMultiplier: { type: "f", value: alphaMul },
                    cntInRow: { type: "i", value: sideImgCount },
                    step: { type: "f", value: rayCastStep },
                    zSize: { type: "f", value: sizeInZ }
                };
                var shaderMaterial =
                new THREE.ShaderMaterial({
                    side: THREE.DoubleSide,
                    uniforms: baseUniforms,
                    vertexShader: document.getElementById('vertexshader').innerHTML,
                    fragmentShader: document.getElementById('xrayfshader').innerHTML
                });

                return shaderMaterial;
            }

            function returnMaterialVolumeLUT() {
                var uniforms = {
                    frontFace: { type: "t", value: frontTexture },
                    backFace: { type: "t", value: backTexture },
                    volume1: { type: "t", value: volumeTexture[0] },
                    volume2: { type: "t", value: volumeTexture[1] },
                    volume3: { type: "t", value: volumeTexture[2] },
                    volume4: { type: "t", value: volumeTexture[3] },
                    transferFce: { type: "t", value: lutTexture },
                    size: { type: "v2", value: new THREE.Vector2(WIDTH, HEIGHT) },
                    alphaMultiplier: { type: "f", value: alphaMul },
                    cntInRow: { type: "i", value: sideImgCount },
                    step: { type: "f", value: rayCastStep },
                    zSize: { type: "f", value: sizeInZ },
                    texelSize: { type: "f", value: 1. / sizeOfTexture },
                    lightPos: { type: "v3", value: camera.position.clone().negate() }
                };

                var shaderMaterial =
                new THREE.ShaderMaterial({
                    side: THREE.DoubleSide,
                    uniforms: uniforms,
                    vertexShader: document.getElementById('vertexshader').innerHTML,
                    fragmentShader: document.getElementById('lutfshader').innerHTML
                });

                return shaderMaterial;
            }

            function returnMaterialVolumeMip() {
                var baseUniforms = {
                    frontFace: { type: "t", value: frontTexture },
                    backFace: { type: "t", value: backTexture },
                    volume1: { type: "t", value: volumeTexture[0] },
                    volume2: { type: "t", value: volumeTexture[1] },
                    volume3: { type: "t", value: volumeTexture[2] },
                    volume4: { type: "t", value: volumeTexture[3] },
                    size: { type: "v2", value: new THREE.Vector2(WIDTH, HEIGHT) },
                    alphaMultiplier: { type: "f", value: alphaMul },
                    cntInRow: { type: "i", value: sideImgCount },
                    step: { type: "f", value: rayCastStep },
                    zSize: { type: "f", value: sizeInZ }
                };
                var shaderMaterial =
                new THREE.ShaderMaterial({
                    side: THREE.DoubleSide,
                    uniforms: baseUniforms,
                    vertexShader: document.getElementById('vertexshader').innerHTML,
                    fragmentShader: document.getElementById('mipfshader').innerHTML
                });

                return shaderMaterial;
            }

            function returnMaterialVolumeIso() {
                var baseUniforms = {
                    frontFace: { type: "t", value: frontTexture },
                    backFace: { type: "t", value: backTexture },
                    volume1: { type: "t", value: volumeTexture[0] },
                    volume2: { type: "t", value: volumeTexture[1] },
                    volume3: { type: "t", value: volumeTexture[2] },
                    volume4: { type: "t", value: volumeTexture[3] },
                    size: { type: "v2", value: new THREE.Vector2(WIDTH, HEIGHT) },
                    alphaMultiplier: { type: "f", value: alphaMul },
                    cntInRow: { type: "i", value: sideImgCount },
                    step: { type: "f", value: rayCastStep },
                    zSize: { type: "f", value: sizeInZ },
                    textureSide: { type: "i", value: sizeOfTexture },
                    texelSize: { type: "f", value: 1. / sizeOfTexture },
                    intensityTreshold: { type: "f", value: intensityT },
                    lightPos: { type: "v3", value: camera.position.clone().negate() }
                }; 

                var shaderMaterial =
                new THREE.ShaderMaterial({
                    side: THREE.DoubleSide,
                    uniforms: baseUniforms,
                    vertexShader: document.getElementById('vertexshader').innerHTML,
                    fragmentShader: document.getElementById('isofshader').innerHTML
                });

                return shaderMaterial;
            }

            function animate() {

                // Read more about requestAnimationFrame at http://www.paulirish.com/2011/requestanimationframe-for-smart-animating/
                if (isRunning)
                    requestAnimationFrame(animate);

                //Vypocet cutting plane
                var planeGeometry = cuttingPlane.cutBox();
                var newPlaneObject = baseFrontCube(planeGeometry);
                var newRayPlaneObject = rayCube(planeGeometry);


                //zmazanie cutting plane
                if (planeObject != undefined) {
                    frontScene.remove(planeObject);
                    //scene.remove(planeObject);
                    scene.remove(rayPlaneObject);
                }
                planeObject = newPlaneObject;
                rayPlaneObject = newRayPlaneObject;
                //pridanie noveho cutting plane
                if (planeObject != undefined) {
                    frontScene.add(planeObject);
                    //scene.add(planeObject);
                    scene.add(rayPlaneObject);
                }


                controls.update();

                setShader();

                // Render front cube.
                renderer.render(frontScene, camera, frontTexture, true);
                //frontTexture.texture.anisotropy = renderer.getMaxAnisotropy();
                // Render back cube.
                renderer.render(backScene, camera, backTexture, true);
                //backTexture.texture.anisotropy = renderer.getMaxAnisotropy();
                //renderer.clear(true, true, true);

                renderer.render(scene, camera);
            }



            function initWebGL(canvas) {
                gl = null;

                try {
                    // Try to grab the standard context. If it fails, fallback to experimental.
                    gl = canvas.getContext("webgl") || canvas.getContext("experimental-webgl");
                }
                catch (e) { }

                // If we don't have a GL context, give up now
                if (!gl) {
                    alert("Unable to initialize WebGL. Your browser may not support it.");
                    gl = null;
                }

                return gl;
            }
        </script>
    </body>
</html>